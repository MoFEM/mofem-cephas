/*! \page faqs Frequently Asked Questions

\section own_documentation How to generate this documentation on your local machine?

In you library directory execute
\code
make doc
\endcode
This create directory \em html. Open file \em html/index.html to see results in your browser.

\section partition_mesh How to partition mesh?

If problem is large, mesh can be partitioned for to save memory and improve efficiency. This can be done using native MoAB tool,
\code
mbpart -t -p PartKway  16 cylinder.cub cylinder_16parts.h5m
\endcode

\section running_multi_grid How to multi-grid solver via approximation orders?

Code is run using direct solver, i.e. \em MUMPS on coarse level. Note that
loaded mesh is portioned and each processor only reads part of the mesh, i.e.
\em  -my_is_partitioned.

\code
mpirun -np 4 ./elasticity \
  -my_file dam_4parts.h5m -my_is_partitioned \
  -ksp_type gmres -ksp_max_it 1000  -ksp_atol 1e-13 -ksp_rtol 0  -ksp_monitor_lg_residualnorm  -ksp_final_residual -ksp_monitor -ksp_converged_reason
  -my_order 1  -my_block_config block_congig.in   \
  -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 -mofem_mg_levels 4  \
  -pc_type mg \
  -mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
  -pc_mg_smoothup 20 -pc_mg_smoothdown 20  -pc_mg_type multiplicative
\endcode

- Option \em -my_is_partitioned is set if mesh is partitioned using \em mbpart
- Option \em -mofem_mg_coarse_order 1 set coarse level is for linear approximation, i.e. order 1.
- Option \em -mofem_mg_levels 4 set number of multi-grid level. In that case maximal approx. order for some part of mesh is 4, thus 4 multi-grid levels.
- Option -pc_mg_smoothup 20 -pc_mg_smoothdown 20 set number of smoothing iterations, for more details look to PETSc manual.
- In line \code
-mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps
\endcode a direct solver for coarse mesh is set.


\section update_on_memory_stick How to update MoFEM on Live USB Stick?

MoFEM update on Live USB stick:
\code
mofem_update.sh
mofem_build.sh
\endcode

Following command run test verifying updated code:
\code
mofem_fast_check.sh
\endcode

If you run MoFEM update at University of Glasgow behind proxy server, set proxy
servers as follows:
\code
export http_proxy=http://wwwcache.gla.ac.uk:8080
export https_proxy=http://wwwcache.gla.ac.uk:8080
\endcode

\section ctest How to run ctest?

You can run tests and report results to MoFEM CDash web page. Form mofem user
modules build directory executing  run script
\code./bin/mofem_fast_check.sh\endcode
Results of test can be seen on <http://cdash.eng.gla.ac.uk/cdash/>.

Note that test tests for MoFEM library and \em User \em Modules are run independently
and can be seen as a two different projects.

If you run test behind proxy server you can have to set \em http_proxy and \em
http_proxy environmental variables. For example if you run mofem at Glasgow
University, please do:
\code
export http_proxy=http://wwwcache.gla.ac.uk:8080
export https_proxy=http://wwwcache.gla.ac.uk:8080
\endcode

You can as well run ctest directly by simply executing command line:
\code
ctest -V -D Experimental
\endcode
where option -V sets verbose version and all test output is printed on screen
and -D Experimental tels ctest to submit results to Experimental build on CDash
MoFEM server.

\section how_to_make_2nd_order_geometry How to make 2nd order gemetry in cubit and transfer it to MoFEM?

In cubit you need to generate 10 node tetrahedral. You simply create block
and set element type to TETRA10, as follows
\code
set duplicate block elements on
block 2 volume 1
block 2 element type TETRA10
\endcode

In the code, you need to create field to keep geometry
\code
ierr = m_field.add_field("MESH_NODE_POSITIONS",H1,3,MF_ZERO); CHKERRQ(ierr);
ierr = m_field.add_ents_to_field_by_TETs(0,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
\endcode
Next set order of approximation field. If you have 10 node tetrahedrons, you
need to have at least 2nd order polynomials to approximate geometry;
\code
ierr = m_field.set_field_order(0,MBTET,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBTRI,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBEDGE,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBVERTEX,"MESH_NODE_POSITIONS",1); CHKERRQ(ierr);
\endcode

The last step is to prject information from 10 node terahedrons on
hierarchical approximation field, as follows
\code
Projection10NodeCoordsOnField ent_method_material(m_field,"MESH_NODE_POSITIONS");
ierr = m_field.loop_dofs("MESH_NODE_POSITIONS",ent_method_material); CHKERRQ(ierr);
\endcode

Look at examples of use to user modules, for example elasticity.cpp.

\section adding_user_module How to add user module?

User module can be independent repository, private or public and independently
managed and owned form MoFEM library. If user module is part of MoFEM repository
can be simply added by adding it to \em ModulesLists.cmake in users modules
directory. However is recommended that user module is project/respository by its
own, repository should be cloned to users modules directory, f.e. in
mofem-cephas/mofem/users_modules \code
git clone https://likask@bitbucket.org/likask/mofem_um_homogenisation.git homogenisation
\endcode

In user module directory directory should be file file, \em
InstalledAddModule.cmake, with content,
\code
add_subdirectory(${PROJECT_SOURCE_DIR}/homogenisation)
\endcode

If user module has documentation (in principle all user modules should have
documentation), if file \em AddDocumentation.cmake, it is executed by cmake
when documentation is build. This cmake script is usually used to copy images and
other files which are linked in documentation.

In each module you can have two type directory data,
  -# Simple
  -# Extended

User module is added to \em ModulesLists.cmake file using cmake command:
\code
add_subdirectory(my_new_module)
\endcode
Simple directory structure consist no subdirectories. f.e. elasticity. Extended (recommended)
data structure consist subdirectories, f.e. homogenization, and follows pattern

\code
-> /atom_tests
-> /src <- hpp files
-> /src/impl <- cpp files form library
-> /meshes
-> /data
-> /doc
\endcode

Not all elements of module source tree are compulsory, however each user module
and new MoFEM functionality should have associated \em atom \em test verifying
implementation and each module should have README file or module documentation
in doc using Doxygen.

It is strongly advised users modules should have one name space, that potential
naming conflicts, f.e. \code
namespace SolidShellModule {
}
\endcode

\section prfiling_code_mac_os_x Profiling code on MacOSX

To profile code in MacOS X environment, from line command you execute \em instruments,
for example
\code
instruments -v -t "Time Profiler" \
./elasticity -my_file LShape.h5m  -ksp_type fgmres -ksp_monitor -my_order 5 \
-pc_type mg -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 \
-mofem_mg_levels 5 -mg_coarse_ksp_type preonly \
-mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
-pc_mg_smoothup 10 -pc_mg_smoothdown 10 -pc_mg_type multiplicative -log_summary
\endcode

This generates directory \em instrumentscli0.trace and for next run
\em instrumentscli1.trace, and similarly for subsequent runs. You can see changes
in execution of the code by 
\code
open instrumentscli0.trace
\endcode

*/
