/*! \page faqs Frequently Asked Questions

\section mofem_citation How to cite us?

If you write a paper using results obtained with the help of MoFEM, please
cite one or more of the following references:

\b Version \b 0.5.42 cite as

DOI:

\htmlonly
<a href="https://doi.org/10.5281/zenodo.438712"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.438712.svg" alt="DOI"></a>
\endhtmlonly

L. Kaczmarczyk, Z. Ullah, K. Lewandowski, Xuan Meng, Xiao-Yi Zhou, C. Pearce. (2017). MoFEM-v0.5.42 [Data set]. Zenodo. http://doi.org/10.5281/zenodo.438712
\code
@misc{mofem_v0.5.42,
  author       = {L. Kaczmarczyk, Z. Ullah, K. Lewandowski, Xuan Meng, Xiao-Yi Zhou, Chris Pearce},
  title        = {MoFEM-v0.5.42},
  month        = mar,
  year         = 2017,
  note         = {http://mofem.eng.gla.ac.uk/mofem/html/},
  doi          = {10.5281/zenodo.438712},
  url          = {https://doi.org/10.5281/zenodo.438712}
}
\endcode

Each user module can have own DOI and reference. All module references
supplements  MoFEM reference. For example homogenisation module DOI as follows

\htmlonly
<a href="https://doi.org/10.5281/zenodo.439368"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.439368.svg" alt="DOI"></a>
\endhtmlonly

\endhtmlonly

\section policy_of_for_version How MoFEM version is changed?

The current MoFEM version can be identified by \e Semantic \e Versioning and \e
Git \e Commit \e Id. \e Git \e Commit \e Id is unique and points to particular
code commit. \e Semantic \e Versioning is not unique, more than one commits to git
repository can have the same version.

First two lines of every executed code which is build with MoFEM library look like that
\code
version 0.3.24  <---  (MAJOR_VERSION.MINOR_VERSION.BUILD_VERSION)
git commit id 3d06924d27973df16e3260c6e962929330cf9348
\endcode
That allows to identify \em git commit id and human readable MoFEM version.

MoFEM is developed continuously (see \ref validation_and_verfication) and any
commit which introducing changes that directly have an impact on users
modules implementation should result in increment \e build \e version. For
example if new functionality is added, name of interface function changed or
some function deprecated etc. that will result in incremented build version.
Note that each users module has set minimal MoFEM version to which is
compatible, see \ref adding_user_module for details.

On the other hand changes/improvements to core library like modification of local
variable name or when local documentation added, that will result in new commit
however will NOT result in new \e build \e version, since implementation of
users modules is not influenced by changes in main library.

Build version is in range from 0-100, at the end of the range minor version
should be automatically incremented. Minor version is in the range from 0-10, at
the end of the range major version should be automatically incremented. The
minor or major version could be changed at any time when major/minor feature is
initiated.

In addition to above rules, the general principles could apply, in short,
- 3.7.11 (bug fix), incremental change in build version
- 3.7.12 (partial new feature, hidden behind a Feature Toggle.), incremental change in build version
- 3.7.13 (performance improvement), incremental change in build version
- 3.8.0 (completed feature initiated in 3.7.12), direct change in minor version
- 4.0.0 (breaking changes in public API), direct change in major version

The MoFEM version can be set in CMakeList.txt located in root source directory,
in lines
\code
set(MoFEM_VERSION_MAJOR 0)
set(MoFEM_VERSION_MINOR 3)
set(MoFEM_VERSION_BUILD 24)
\endcode

\section validation_and_verfication How MoFEM is developed?

MoFEM is developed continuously, i.e. any merged pull request to the
CDashTesting branch triggers automatic testing on the development server. The
code is verified during when a pull request is accepted and merged and validated
when the test on the development server are passed. If tests are passed
CDashBranch is merged to master branch.

\section own_documentation How to generate this documentation on your local machine?

In you library directory execute
\code
make doc
\endcode
This create directory \em html. Open file \em html/index.html to see results in your browser.

\section partition_mesh How to partition mesh?

If problem is large, mesh can be partitioned for to save memory and improve efficiency. This can be done using native MoFEM tool,
\code
$USER_MODULES/tools/mofem_part -my_file $USER_MODULES/basic_finite_elements/nonlinear_elasticity/examples/cylinder.cub -my_nparts 16
\endcode
The partitioned mesh is saved to file *out.h5m* in current working directory.

For large meshes, partitioning can be in parallel, for example
\code
mpirun -np 2 $USER_MODULES/tools/mofem_part -my_file $USER_MODULES/basic_finite_elements/nonlinear_elasticity/examples/cylinder.cub -my_nparts 16
\endcode

\section running_multi_grid How to run multi-grid solver via approximation orders?

Code is run using direct solver, i.e. \em MUMPS on coarse level. Note that
loaded mesh is portioned and each processor only reads part of the mesh, i.e.
\em  -my_is_partitioned.

\code
mpirun -np 4 ./elasticity \
  -my_file dam_4parts.h5m -my_is_partitioned \
  -ksp_type gmres -ksp_max_it 1000  -ksp_atol 1e-13 -ksp_rtol 0  -ksp_monitor_lg_residualnorm  -ksp_final_residual -ksp_monitor -ksp_converged_reason
  -my_order 1  -my_block_config block_congig.in   \
  -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 -mofem_mg_levels 4  \
  -pc_type mg \
  -mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
  -pc_mg_smoothup 20 -pc_mg_smoothdown 20  -pc_mg_type multiplicative
\endcode

- Option \em -my_is_partitioned is set if mesh is partitioned using \em mbpart
- Option \em -mofem_mg_coarse_order 1 set coarse level is for linear approximation, i.e. order 1.
- Option \em -mofem_mg_levels 4 set number of multi-grid level. In that case maximal approx. order for some part of mesh is 4, thus 4 multi-grid levels.
- Option -pc_mg_smoothup 20 -pc_mg_smoothdown 20 set number of smoothing iterations, for more details look to PETSc manual.
- In line \code
-mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps
\endcode a direct solver for coarse mesh is set.

\section how_to_make_2nd_order_geometry How to make 2nd order geometry in cubit and transfer it to MoFEM?

In cubit you need to generate 10 node tetrahedral. You simply create block
and set element type to TETRA10, as follows
\code
set duplicate block elements on
block 2 volume 1
block 2 element type TETRA10
\endcode

In the code, you need to create field to keep geometry
\code
ierr = m_field.add_field("MESH_NODE_POSITIONS",H1,3,MF_ZERO); CHKERRQ(ierr);
ierr = m_field.add_ents_to_field_by_TETs(0,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
\endcode
Next set order of approximation field. If you have 10 node tetrahedrons, you
need to have at least 2nd order polynomials to approximate geometry;
\code
ierr = m_field.set_field_order(0,MBTET,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBTRI,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBEDGE,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBVERTEX,"MESH_NODE_POSITIONS",1); CHKERRQ(ierr);
\endcode

The last step is to prject information from 10 node terahedrons on
hierarchical approximation field, as follows
\code
Projection10NodeCoordsOnField ent_method_material(m_field,"MESH_NODE_POSITIONS");
ierr = m_field.loop_dofs("MESH_NODE_POSITIONS",ent_method_material); CHKERRQ(ierr);
\endcode

Look at examples of use to user modules, for example elasticity.cpp.

\section adding_user_module How to add user module?

MoFEM is a core library providing functionality for implementation of user
modules where applications for particular finite elements or problems are
implemented. User module is an independent repository, private or public and
independently managed by its owner.

User module is added to the project by cloning repository into directory
$HOME/mofem-cephas/mofem/users_modules, for example, module for computational
homogenisation has repository in Bitbucket and can be added by
\code
cd $HOME/mofem-cephas/mofem/users_modules
git clone https://likask@bitbucket.org/likask/mofem_um_homogenisation.git homogenisation
\endcode
Sometimes users modules depend on other modules, in that case, homogenisation
module uses some old obsolete classes (which should not be used in new
developments), thus in this particular case addition you have to clone  also
obsolete module
\code
git clone https://likask@bitbucket.org/likask/mofem_um_obsolete.git obsolete
\endcode

Once the module is added, you have to go main build directory where users
modules are located and rebuild the code. So you have to do
\code
cd $HOME/mofem_build/um
touch CMakeCache.txt
make -j 4
\endcode
Note the first command is used to trigger reconfiguration of users modules with the new module.

Note, each user module consist InstalledAddModule.cmake, with beginning lines,
\code
# Check minimum version of MoFEM with this module works
check_mofem_version(0 5 63)
add_subdirectory(${PROJECT_SOURCE_DIR}/homogenisation)
\endcode
In that file minimal version of the core library is given (e.g. v0.5.63). Thus
if you have too old version of core lib, it won't be added and cmake will
generate an error. In that case, you need to update core library by pulling most
recent version from Bitbucket repository and install core library.

User module can be independent repository, private or public and independently
managed and owned form MoFEM library. If user module is part of MoFEM repository
can be simply added by adding it to \em ModulesLists.cmake in users modules
directory. However is recommended that user module is project/respository by its
own, repository should be cloned to users modules directory, f.e. in
mofem-cephas/mofem/users_modules \code
git clone https://likask@bitbucket.org/likask/mofem_um_homogenisation.git homogenisation
\endcode

In user module directory directory should be file file, \em
InstalledAddModule.cmake, with content,
\code
# Check monimimal version of MoFEM with this module works
check_mofem_version(0 3 6)
add_subdirectory(${PROJECT_SOURCE_DIR}/homogenisation)
\endcode

\section prfiling_code_mac_os_x How to profile code using XCode tools?

To profile code in MacOS X environment, from line command you execute \em instruments,
for example
\code
instruments -v -t "Time Profiler" \
./elasticity -my_file LShape.h5m  -ksp_type fgmres -ksp_monitor -my_order 5 \
-pc_type mg -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 \
-mofem_mg_levels 5 -mg_coarse_ksp_type preonly \
-mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
-pc_mg_smoothup 10 -pc_mg_smoothdown 10 -pc_mg_type multiplicative -log_view
\endcode

This generates directory \em instrumentscli0.trace and for next run
\em instrumentscli1.trace, and similarly for subsequent runs. You can see changes
in execution of the code by
\code
open instrumentscli0.trace
\endcode

If you use Linux you can alternatively use Valgrind, see \ref profiling_code_with_valgrind.

\section profiling_code_stages How to profile code using PETSc tools?

See PETSc documentation
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Profiling/PetscLogStageRegister.html>
and examples
<http://www.mcs.anl.gov/petsc/petsc-current/src/ksp/ksp/examples/tutorials/ex9.c.html>

\section profiling_code_with_valgrind How to profile code with Valgrind?

You have to install Valgrind <http://valgrind.org> and graphic user interface
KCachegrind <http://kcachegrind.sourceforge.net/html/Home.html>. If you using Linux,
for example ubuntu you can do that executing following commands,
\code
sudo apt-get install valgrind kcachegrind
\endcode
If you using OS X you can use Homebrew <http://brew.sh> to make installation,
\code
brew install valgrind
brew install qcachegrind --with-graphviz
\endcode

If you have packages installed, follow instruction from <http://kcachegrind.sourceforge.net/html/Documentation.html>

\section debugging_in_docker How to make debugging in docker?

You can use gdb inside docker, remembering to set cmake with debugging
build type, for example
\code
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-Wall" users_modules
\endcode

It is one non trivial trick that you have to do, to make debugging possible in
docker, you need to run docker container in \em privileged mode, for example
\code
docker run --privileged -it --name work --hostname mofem -v $HOME:/mnt/home -v mofem_build:/my_build likask/mofem_build:v0.2 /bin/bash
\endcode

\section configure_vs_code How to configure MoFEM in Visual Studio Code?

Basic support for C/C++ languages is provided with <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"> Microsoft C/C++ extension</a>. 
To configure IntelliSense code-completion tool add \p -DCMAKE_EXPORT_COMPILE_COMMANDS=1 to users_modules's cmake command. 
This will generate \p compile_commands.json file which has to be added to \p .vscode/c_cpp_properties.json 
file located in the working project. Example \p c_cpp_properties configuration on Mac should look like follows:
\code
{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [],
            "macFrameworkPath": [
                "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/
                SDKs/MacOSX10.13.sdk/System/Library/Frameworks"
            ],
            "compilerPath": "/usr/bin/clang",
            "cStandard": "c11",
            "cppStandard": "c++14",
            "intelliSenseMode": "clang-x64",
            "compileCommands": "/Users/User1/mofem_install/users_modules_debug/compile_commands.json"

        }
    ],
    "version": 4
}
\endcode

\section vs_code_debug How to setup LLDB debugger in Visual Studio Code?
For debugging on Mac the most commonly used extension is <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb"> CodeLLDB</a> plugin. 
The configuration is straightforward: choose \p lldb type, set the path to the executable (compiled with debug flag!) as \p program, arguments for the
command line put in \p args. Optionally, the path to current working directory can be set (\p cwd). Example configuration for fracture module is presented
below.
\code 
    "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug_my_crack1",
      "program": "/Users/User1/moFEM/users_modules_debug/fracture_mechanics/crack_propagation",
      "args": [
        "-my_file",
        "LShape.h5m",
        "-pc_factor_mat_solver_package",
        "mumps",
        "-ksp_monitor"
      ],
      "cwd": "/Users/User1/mofem_install/users_modules_debug/fracture_mechanics"
    }
  ]
\endcode

\section users_modules_changes_affects_mainRepo Why do users_modules changes affect mofem-cephas/mofem git repository?

When making changes in a users_modules, a git submodule, the main git repo
will register a version change. For example:
\code
cd mofem-cephas/mofem
git diff

diff --git a/mofem/users_modules b/mofem/users_modules
index d18f43f88..42bcece0e 160000
--- a/mofem/users_modules
+++ b/mofem/users_modules
@@ -1 +1 @@
-Subproject commit d18f43f884bfbfbce50f0f70155d911a2d361164
+Subproject commit 42bcece0e7e6577b83bb2a5c64d2709a2bc15b47
\endcode

The commit ID of the submodule is used to track which version to pull when
pulling the main repo. Updating to the latest commit will then pull the your
latest changes.

*/
