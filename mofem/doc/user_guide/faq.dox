/*! \page faqs Frequently Asked Questions

\section mofem_citation How to cite us?

If you write a paper using results obtained with the help of MoFEM, please
cite one or more of the following references:

\b Version \b 0.5.42 cite as

DOI:

\htmlonly
<a href="https://doi.org/10.5281/zenodo.438712"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.438712.svg" alt="DOI"></a>
\endhtmlonly

L. Kaczmarczyk, Z. Ullah, K. Lewandowski, Xuan Meng, Xiao-Yi Zhou, C. Pearce. (2017). MoFEM-v0.5.42 [Data set]. Zenodo. http://doi.org/10.5281/zenodo.438712
\code
@misc{mofem_v0.5.42,
  author       = {L. Kaczmarczyk, Z. Ullah, K. Lewandowski, Xuan Meng, Xiao-Yi Zhou, Chris Pearce},
  title        = {MoFEM-v0.5.42},
  month        = mar,
  year         = 2017,
  note         = {http://mofem.eng.gla.ac.uk/mofem/html/},
  doi          = {10.5281/zenodo.438712},
  url          = {https://doi.org/10.5281/zenodo.438712}
}
\endcode

Each user module can have own DOI and reference. All module references
supplements  MoFEM reference. For example homogenisation module DOI as follows

\htmlonly
<a href="https://doi.org/10.5281/zenodo.439368"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.439368.svg" alt="DOI"></a>
\endhtmlonly

\endhtmlonly

\section policy_of_for_version How MoFEM version is changed?

The current MoFEM version can be identified by \e Semantic \e Versioning and \e
Git \e Commit \e Id. \e Git \e Commit \e Id is unique and points to particular
code commit. \e Semantic \e Versioning is not unique, more than one commits to git
repository can have the same version.

First two lines of every executed code which is build with MoFEM library look like that
\code
version 0.3.24  <---  (MAJOR_VERSION.MINOR_VERSION.BUILD_VERSION)
git commit id 3d06924d27973df16e3260c6e962929330cf9348
\endcode
That allows to identify \em git commit id and human readable MoFEM version.

MoFEM is developed continuously (see \ref validation_and_verfication) and any
commit which introducing changes that directly have an impact on users
modules implementation should result in increment \e build \e version. For
example if new functionality is added, name of interface function changed or
some function deprecated etc. that will result in incremented build version.
Note that each users module has set minimal MoFEM version to which is
compatible, see \ref adding_user_module for details.

On the other hand changes/improvements to core library like modification of local
variable name or when local documentation added, that will result in new commit
however will NOT result in new \e build \e version, since implementation of
users modules is not influenced by changes in main library.

Build version is in range from 0-100, at the end of the range minor version
should be automatically incremented. Minor version is in the range from 0-10, at
the end of the range major version should be automatically incremented. The
minor or major version could be changed at any time when major/minor feature is
initiated.

In addition to above rules, the general principles could apply, in short,
- 3.7.11 (bug fix), incremental change in build version
- 3.7.12 (partial new feature, hidden behind a Feature Toggle.), incremental change in build version
- 3.7.13 (performance improvement), incremental change in build version
- 3.8.0 (completed feature initiated in 3.7.12), direct change in minor version
- 4.0.0 (breaking changes in public API), direct change in major version

The MoFEM version can be set in CMakeList.txt located in root source directory,
in lines
\code
set(MoFEM_VERSION_MAJOR 0)
set(MoFEM_VERSION_MINOR 3)
set(MoFEM_VERSION_BUILD 24)
\endcode

\section validation_and_verfication How MoFEM is developed?

MoFEM is developed continuously, i.e. any merged pull request to the
\em CDashTesting branch triggers automatic testing on the development server. Code is
verified during when pull request is accepted and merged and validated when
test on the development server are passed. If tests are passed \em CDashBranch is
merged to \em release branch.

\section own_documentation How to generate this documentation on your local machine?

In you library directory execute
\code
make doc
\endcode
This create directory \em html. Open file \em html/index.html to see results in your browser.

\section partition_mesh How to partition mesh?

If problem is large, mesh can be partitioned for to save memory and improve efficiency. This can be done using native MoFEM tool,
\code
$USER_MODULES/tools/mofem_part -my_file $USER_MODULES/basic_finite_elements/nonlinear_elasticity/examples/cylinder.cub -my_nparts 16
\endcode
The partitioned mesh is saved to file *out.h5m* in current working directory.

For large meshes, partitioning can be in parallel, for example
\code
mpirun -np 2 $USER_MODULES/tools/mofem_part -my_file $USER_MODULES/basic_finite_elements/nonlinear_elasticity/examples/cylinder.cub -my_nparts 16
\endcode

\section running_multi_grid How to multi-grid solver via approximation orders?

Code is run using direct solver, i.e. \em MUMPS on coarse level. Note that
loaded mesh is portioned and each processor only reads part of the mesh, i.e.
\em  -my_is_partitioned.

\code
mpirun -np 4 ./elasticity \
  -my_file dam_4parts.h5m -my_is_partitioned \
  -ksp_type gmres -ksp_max_it 1000  -ksp_atol 1e-13 -ksp_rtol 0  -ksp_monitor_lg_residualnorm  -ksp_final_residual -ksp_monitor -ksp_converged_reason
  -my_order 1  -my_block_config block_congig.in   \
  -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 -mofem_mg_levels 4  \
  -pc_type mg \
  -mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
  -pc_mg_smoothup 20 -pc_mg_smoothdown 20  -pc_mg_type multiplicative
\endcode

- Option \em -my_is_partitioned is set if mesh is partitioned using \em mbpart
- Option \em -mofem_mg_coarse_order 1 set coarse level is for linear approximation, i.e. order 1.
- Option \em -mofem_mg_levels 4 set number of multi-grid level. In that case maximal approx. order for some part of mesh is 4, thus 4 multi-grid levels.
- Option -pc_mg_smoothup 20 -pc_mg_smoothdown 20 set number of smoothing iterations, for more details look to PETSc manual.
- In line \code
-mg_coarse_ksp_type preonly -mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps
\endcode a direct solver for coarse mesh is set.


\section update_on_memory_stick How to update MoFEM on Live USB Stick?

MoFEM update on Live USB stick:
\code
mofem_update.sh
mofem_build.sh
\endcode

Following command run test verifying updated code:
\code
mofem_fast_check.sh
\endcode

If you run MoFEM update at University of Glasgow behind proxy server, set proxy
servers as follows:
\code
export http_proxy=http://wwwcache.gla.ac.uk:8080
export https_proxy=http://wwwcache.gla.ac.uk:8080
\endcode

\section ctest How to run ctest?

You can run tests and report results to MoFEM CDash web page. Form mofem user
modules build directory executing  run script
\code./bin/mofem_fast_check.sh\endcode
Results of test can be seen on <http://cdash.eng.gla.ac.uk/cdash/>.

Note that test tests for MoFEM library and \em User \em Modules are run independently
and can be seen as a two different projects.

If you run test behind proxy server you can have to set \em http_proxy and \em
http_proxy environmental variables. For example if you run mofem at Glasgow
University, please do:
\code
export http_proxy=http://wwwcache.gla.ac.uk:8080
export https_proxy=http://wwwcache.gla.ac.uk:8080
\endcode

You can as well run ctest directly by simply executing command line:
\code
ctest -V -D Experimental
\endcode
where option -V sets verbose version and all test output is printed on screen
and -D Experimental tels ctest to submit results to Experimental build on CDash
MoFEM server.

\section how_to_make_2nd_order_geometry How to make 2nd order gemetry in cubit and transfer it to MoFEM?

In cubit you need to generate 10 node tetrahedral. You simply create block
and set element type to TETRA10, as follows
\code
set duplicate block elements on
block 2 volume 1
block 2 element type TETRA10
\endcode

In the code, you need to create field to keep geometry
\code
ierr = m_field.add_field("MESH_NODE_POSITIONS",H1,3,MF_ZERO); CHKERRQ(ierr);
ierr = m_field.add_ents_to_field_by_TETs(0,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
\endcode
Next set order of approximation field. If you have 10 node tetrahedrons, you
need to have at least 2nd order polynomials to approximate geometry;
\code
ierr = m_field.set_field_order(0,MBTET,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBTRI,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBEDGE,"MESH_NODE_POSITIONS",2); CHKERRQ(ierr);
ierr = m_field.set_field_order(0,MBVERTEX,"MESH_NODE_POSITIONS",1); CHKERRQ(ierr);
\endcode

The last step is to prject information from 10 node terahedrons on
hierarchical approximation field, as follows
\code
Projection10NodeCoordsOnField ent_method_material(m_field,"MESH_NODE_POSITIONS");
ierr = m_field.loop_dofs("MESH_NODE_POSITIONS",ent_method_material); CHKERRQ(ierr);
\endcode

Look at examples of use to user modules, for example elasticity.cpp.

\section adding_user_module How to add user module?

User module can be independent repository, private or public and independently
managed and owned form MoFEM library. If user module is part of MoFEM repository
can be simply added by adding it to \em ModulesLists.cmake in users modules
directory. However is recommended that user module is project/respository by its
own, repository should be cloned to users modules directory, f.e. in
mofem-cephas/mofem/users_modules \code
git clone https://likask@bitbucket.org/likask/mofem_um_homogenisation.git homogenisation
\endcode

In user module directory directory should be file file, \em
InstalledAddModule.cmake, with content,
\code
# Check monimimal version of MoFEM with this module works
check_mofem_version(0 3 6)
add_subdirectory(${PROJECT_SOURCE_DIR}/homogenisation)
\endcode

If user module has documentation (in principle all user modules should have
documentation), if file \em AddDocumentation.cmake, it is executed by cmake
when documentation is build. This cmake script is usually used to copy images and
other files which are linked in documentation.

In each module you can have two type directory data,
  -# Simple
  -# Extended

User module is added to \em ModulesLists.cmake file using cmake command:
\code
add_subdirectory(my_new_module)
\endcode
Simple directory structure consist no subdirectories. f.e. elasticity. Extended (recommended)
data structure consist subdirectories, f.e. homogenization, and follows pattern

\code
-> /atom_tests
-> /src <- hpp files
-> /src/impl <- cpp files form library
-> /meshes
-> /data
-> /doc
\endcode

Not all elements of module source tree are compulsory, however each user module
and new MoFEM functionality should have associated \em atom \em test verifying
implementation and each module should have README file or module documentation
in doc using Doxygen.

It is strongly advised users modules should have one name space, that potential
naming conflicts, f.e. \code
namespace SolidShellModule {
}
\endcode

\section prfiling_code_mac_os_x How to profile code using XCode tools?

To profile code in MacOS X environment, from line command you execute \em instruments,
for example
\code
instruments -v -t "Time Profiler" \
./elasticity -my_file LShape.h5m  -ksp_type fgmres -ksp_monitor -my_order 5 \
-pc_type mg -mofem_mg_verbose 1 -mofem_mg_coarse_order 1 \
-mofem_mg_levels 5 -mg_coarse_ksp_type preonly \
-mg_coarse_pc_type lu -mg_coarse_pc_factor_mat_solver_package mumps \
-pc_mg_smoothup 10 -pc_mg_smoothdown 10 -pc_mg_type multiplicative -log_view
\endcode

This generates directory \em instrumentscli0.trace and for next run
\em instrumentscli1.trace, and similarly for subsequent runs. You can see changes
in execution of the code by
\code
open instrumentscli0.trace
\endcode

If you use Linux you can alternatively use Valgrind, see \ref profiling_code_with_valgrind.

\section profiling_code_stages How to profile code using PETSc tools?

See PETSc documentation
<http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Profiling/PetscLogStageRegister.html>
and examples
<http://www.mcs.anl.gov/petsc/petsc-current/src/ksp/ksp/examples/tutorials/ex9.c.html>

\section profiling_code_with_valgrind How to profile code with Valgrind?

You have to install Valgrind <http://valgrind.org> and graphic user interface
KCachegrind <http://kcachegrind.sourceforge.net/html/Home.html>. If you using Linux,
for example ubuntu you can do that executing following commands,
\code
sudo apt-get install valgrind kcachegrind
\endcode
If you using OS X you can use Homebrew <http://brew.sh> to make installation,
\code
brew install valgrind
brew install qcachegrind --with-graphviz
\endcode

If you have packages installed, follow instruction from <http://kcachegrind.sourceforge.net/html/Documentation.html>

\section debugging_in_docker How to make debugging in docekr?

You can use gdb inside docker, remembering to set cmake with debugging
build type, for example
\code
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-Wall" users_modules
\endcode

It is one non trivial trick that you have to do, to make debugging possible in
docker, you need to run docker container in \em privileged mode, for example
\code
docker run --privileged -it --name work --hostname mofem -v $HOME:/mnt/home -v mofem_build:/my_build likask/mofem_build:v0.2 /bin/bash
\endcode

\section Who contribuiting to MoFEM?

MoFEM is copyright by Lukasz Kaczmarczyk (Lukasz.Kaczmarczyk at glasgow.ac.uk)
and has received contributions by several people. MoFEM can be used freely for
educational, research or commercial purposes by other institutions.

Users modules are not part of MoFEM library and can be created privately,
independently form MoFEM developers. User modules may follow different license
agreement and copyrights. However, all users modules which are created at Glasgow
University are under the same license agreement as main MoFEM library.

List is generated automatically at time when documentation is build based on
contributions to main git repository. Note that particular module can have
separate contributors list. If one author uses more than one name the same person
can appear more than once.

Detailed git-statistic for core lib only <http://mofem.eng.gla.ac.uk/mofem/html/git-stats>

\verbinclude doc/contributors_list
\verbinclude users_modules/doc/contributors_list_modules

List is generated with command,
\code
git shortlog -s -e -n
\endcode

Note that contributions to forked module are not on the list.


*/
