/*! \page tutorials Tutorials

Step by step tutorial for MoFEM developers. We explain here how to implement
general problem on particular examples.

\tableofcontents

\section snes_nonlinear_tut Nonlinear problem

Minimal surface area (soap film on the wire): Tutorial showing step by step
implementation of nonlinear problem. It presents how to set up the problem
from scratch, calculate matrices and solve the problem using MoFEM and
PETSc

- \subpage sope_film

\section mix_adpativity_tut Mix formulation and h-adaptivity

In example is shown how to solve transport problem using mix element with an
independent approximation for fluxes and function values.  Also, is shown how to
integrate over mesh skeleton to evaluate error and how to use a posterior error
estimator to drive mesh adaptivity (h-adaptivity),

- \subpage ultraw_weak

\section before_finite_element_tut Before you start to look into examples and tuorials

\subsection finite_element_tut Finite element and UserDataOperator

The finite element entity is composed of sub entities, like nodes, edges, faces
(triangle, quad, etc.) and volumes (tetrahedron, hex, prism, etc.)  The element
is implemented by evaluating base functions, indices, data on each entity in the
body of the element. The developer does not directly implement finite element
for given predefined type, but UserDataOprators operating on finite element
entities.  In such method order of approximation, the shape of the finite
element does not influence how user implements problem.

Moreover, unlike in common finite element code, choice of field space and base
space is independent of the type of element, it happens before we select the
domain of integration and finite elements on it. Concepts like the periodic
table of finite elements, or zoo of finite elements are obsolete.

We use the concept of a finite element as a domain on which integration rule is
constructed and base functions evaluated. The finite element has an auxiliary
set of data, for example, a measure of the domain, i.e. volume, area or length.
Some elements carry information about normal, direction depending on the
dimension of the finite element domain. The base finite element interface can be
seen here \ref MoFEM::ForcesAndSurcesCore. Note that most of the derived
classes, alter finite element behaviour in minimally, usually by altering rule
of integration, appropriately to order and type of differential operators on the
element. The structure and finite element interaction with user data operators
are shown in the figure below
\image html fe_struture_1.png "Finite element and is structure" width=800px

The fundamental role in finite element implementation plays \ref
MoFEM::ForcesAndSurcesCore::UserDataOperator. The generality of this technology
range of applications 2d or 3d, with Nitsche's method or with H-div or H-curl
spaces. The UserDataOprator are operated in three distinct types, first usually
used to evaluate the right-hand side vectors, second to evaluate the left-hand
side matrices, and third often use to modify base functions.  First two are
intrinsically linked to operations on particular fields, the last one is
abstract and should not be used to assemble vectors and matrices. Users
operators are run in sequence as are added to finite element and executed or
each entity on that element. If for given field number of DOFs or base functions
on given entity is zero, such entity is not evaluated.
\image html fe_struture_2.png "Types of UserDataOperator" width=800px

Note that data and algorithm operating on data is localised,  and grouped by
element and by an entity. Elements and entities share data structure avoiding
unnecessary memory allocation and deallocation.  However, the mobilisation for
this development is code reusability, which with relatively small code large
group of problems can be implemented and last but not least enables
modularisation and testing of each element independently.
\image html fe_struture_3.png "Example of implementation" width=800px



*/
