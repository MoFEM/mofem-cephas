/*! \page tutorials Tutorials

Step by step tutorial for MoFEM developers. We explain here how to implement
general problem on particular examples.

\tableofcontents

\section snes_nonlinear_tut Nonlinear problem

Minimal surface area (soap film on the wire): Tutorial showing step by step
implementation of nonlinear problem. It presents how to set up the problem
from scratch, calculate matrices and solve the problem using MoFEM and
PETSc

- \subpage sope_film

\section mix_adpativity_tut Mix formulation and h-adaptivity

In example is shown how to solve transport problem using mix element with an
independent approximation for fluxes and function values.  Also, is shown how to
integrate over mesh skeleton to evaluate error and how to use a posterior error
estimator to drive mesh adaptivity (h-adaptivity),

- \subpage ultraw_weak

\section before_finite_element_tut Before you start to look into examples and tuorials

\subsection mofem_eccosystem MoFEM software eccosystem

Finite element software is a complex ecosystem, managing mesh and topology
related complexities, sparse algebra and complications related to approximation,
integration or dense tensor algebra at integration point level. Each element by
itself is a stand alone complicated problem. MoFEM ecosystem is composed of
three disincentive parts, MoAB managing complexities related to topology, PETSc
managing complexities related to sparse algebra and solvers and finally MoAB
core library managing complexities directly related to finite element method.
Each part has its own design objectives, and appropriate programming tools from
a spectrum of solutions can be selected \cite knepley2012programming. MoFEM make
PETSc integral part of code, by extending PETSc by DMMOFEM interface (several
other functions work directly on PETSc objects).  MoAB from other hand is
internal data storage. PETSc is designed to be fast, whereas MoAB aims to be
memory efficient.
\image html data_strutures_1.png "MoFEM code parts" width=800px

Code development is a compromise of different goals. First primary deign
objective is to develop flexible & extendable code easy to test and bug search.
Very often we spend more time to implement finite element that time needed to
run analysis itself, flexibility & extensibility allow for rapid development of
finite elements for non-standard and complex problems. Utilising PETSc and MoAB
scalability is second important design objective. Nowadays we can have easy
access to the computing clusters through could computing or local/regional
supercomputers. Third, core library can not compromise runtime efficiency and
use computer memory with care.

\subsection finite_element_tut Finite element implementation and UserDataOperator

The finite element entity is composed of sub entities, like nodes, edges, faces
(triangle, quad, etc.) and volumes (tetrahedron, hex, prism, etc.)  The element
is implemented by evaluating base functions, indices, data on each entity in the
domain of the element. The developer does not directly implement finite element
for given predefined type, but UserDataOprators operating on finite element
entities.  In such method order of approximation, the shape of the finite
element does not influence how user implements problem.

Moreover, unlike in common finite element code, choice of field space and base
space is independent of the type of element, it happens before we select the
domain of integration and finite elements on it. Concepts like the periodic
table of finite elements, or zoo of finite elements are obsolete.

We use the concept of a finite element as a domain on which integration rule is
constructed and base functions evaluated. The finite element has an auxiliary
set of data, for example, a measure of the domain, i.e. volume, area or length.
Some elements carry information about normal, direction depending on the
dimension of the finite element domain. The base finite element interface can be
seen here \ref MoFEM::ForcesAndSurcesCore. Note that most of the derived
classes, alter finite element behaviour in minimally, usually by altering rule
of integration, appropriately to order and type of differential operators on the
element. The structure and finite element interaction with user data operators
are shown in the figure below
\image html fe_struture_1.png "Finite element and is structure" width=800px

The fundamental role in finite element implementation plays \ref
MoFEM::ForcesAndSurcesCore::UserDataOperator. The generality of this technology
range of applications 0d-2d or 3d, with Nitsche's method or with H-div or H-curl
spaces. The UserDataOprator are operated in three typical ways, first (\a OPROW/
\a OPCOL) usually used to evaluate the right-hand side vectors, second (\a
OPROWCOL) to evaluate the left-hand side matrices, and third, often use to
modify base functions of given space.  First two are intrinsically linked to
operations on particular fields, the last one is abstract and should not be used
to assemble vectors and matrices. Type of operator is set by overloading
function \c doWrok. Operators are run in sequence as are added to finite element
and executed or each entity on that element. If for given field number of DOFs
or base functions on given entity is zero, such entity is not evaluated.
\image html fe_struture_2.png "Types of UserDataOperator" width=800px

Note that data and algorithm operating on data is localised, and grouped by
element and by an entity. Elements and entities share data structure avoiding
unnecessary memory allocation and deallocation. However, the motivation for this
development is code elasticity (resilience to change and openness for new finite
element technologies), reusability, which with relatively small code large group
of problems can be implemented and last but not least enables modularisation and
testing of each element independently.
\image html fe_struture_3.png "Example of implementation" width=800px
Above example reflect how an engineer would formulate the problem for linear
thermoelasticity, calculate physical quantities like strain, stress, temperature
or flux and assemble a system of linear equations to solve it staggered method.
Another way approaching this problem to think regarding differential operators. One can
implement set of operators,
\f[
(\nabla u ,\nabla u),\;(\nabla \cdot \tau, u),\;(u,u)
\f]
and example, assembly of
\f[
\mathbf{A} = (\nabla u,\nabla u)_\Omega =  \int_\Omega
\nabla \mathbf{u} \cdot \nabla \mathbf{v}
\textrm{d}\Omega
\f]
take form
\code
struct OpGradGrad: public MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator {

  Mat A;
  OpGradGrad(Mat a):
  MoFEM::VolumeElementForcesAndSourcesCore::UserDataOperator("U","U",UserDataOperator::OPROWCOL,true).
  A(a) {
  }

  MatrixDouble entityLocalMatrix;

  /**
   * \brief integrate matrix
   * @param  row_side local number of entity on element for row of the matrix
   * @param  col_side local number of entity on element for col of the matrix
   * @param  row_type type of row entity (VERTICES/EDGE0-5/TRIANGLE0-3/TETRAHEDRON)
   * @param  col_type type of col entity (VERTICES/EDGE0-5/TRIANGLE0-3/TETRAHEDRON)
   * @param  row_data structure of data, like base functions and associated methods to access those data on rows
   * @param  col_data structure of data, like base functions and associated methods to access those data on rows
   * @return          error code
   */
  PetscErrorCode doWork(
    int row_side,int col_side,
    EntityType row_type,EntityType col_type,
    DataForcesAndSurcesCore::EntData &row_data,
    DataForcesAndSurcesCore::EntData &col_data
  ) {
    PetscErrorCode ierr;
    PetscFunctionBegin;

    // get number of dofs on rows
    const int nb_row_dofs = row_data.getIndices().size();
    // if no dofs, end here
    if(nb_row_dofs==0) PetscFunctionReturn(0);
    // get number of dofs on column
    const int nb_col_dofs = col_data.getIndices().size();
    // if no dofs, end here
    if(nb_col_dofs==0) PetscFunctionReturn(0);

    // resize entity local matrix
    entityLocalMatrix.resize(nb_row_dofs,nb_col_dofs,false);
    // zero elements
    entityLocalMatrix.clear();

    // get number of integration points
    const int nb_gauss_pts = row_data.getHcurlN().size1();

    // integrate
    for(int gg = 0;gg!=nb_gauss_pts;gg++) {
      // get integration weight scaled by volume
      double w = getGaussPts()(3,gg)*getVolume();
      // get direvatives of base functions on rows
      FTensor::Tensor1<double*,Tensor_Dim> t_base_diff_row = row_data.getFTensor1DiffN();
      // loop rows
      for(int aa = 0;aa!=nb_row_dofs;aa++) {
        // take first element in row "aa"
        FTensor::Tensor0<double*> t_local_mat(
          &entityLocalMatrix(aa,0),1
        );
        // get direvatives of base functions on columns
        FTensor::Tensor1<double*,Tensor_Dim> t_base_diff_col = col_data.getFTensor1DiffN();
        // loop column
        for(int bb = 0;bb!=nb_col_dofs;bb++) {
          FTensor::Index<'i',3> i;
          t_local_mat += w*t_base_diff_row(i)*t_base_diff_col(i);
          ++t_base_diff_col;
          ++t_local_mat;
        }
        ++t_base_diff_row;
      }

      // if row_side != col_side || row_type != col_type we can exploit
      // symetry of matrux entityLocalMatrix, for simplicty we do
      // not do it here

    }

    // assemble global matrix
    ierr = MatSetValues(
      blockData.A,
      nb_row_dofs,&row_data.getIndices()[0],
      nb_col_dofs,&col_data.getIndices()[0],
      &entityLocalMatrix(0,0),ADD_VALUES
    ); CHKERRQ(ierr);
    // and its transpose
    if(row_side != col_side || row_type != col_type) {
      entityLocalMatrix = trans(entityLocalMatrix);
      ierr = MatSetValues(
        A,
        nb_col_dofs,&col_data.getIndices()[0],
        nb_row_dofs,&row_data.getIndices()[0],
        &entityLocalMatrix(0,0),ADD_VALUES
      ); CHKERRQ(ierr);
    }

    PetscFunctionReturn(0);
  }

};
\endcode

\subsection mofem_data_flow Core library and application code

Typically internal data structures are hidden from the user and are no need to
access them directly. In core library, no single problem or finite element in
the classical sense is implemented. Core library only provides functionality for
finite element implementation and application code development. For that reason
repositories of core library and users modules are in separate independent
repositories.
\image html data_strutures_2.png "MoFEM code parts" width=800px

In the figure above on first instant, a developer is interested in the
implementation of users data operators and tasks in the yellow boxes. It has to
define fields, which span on some entities and set approximation order. For example
\code
MoFEM::Core core(moab);
MoFEM::Interface& m_field = core;
// define fields
ierr = m_field.add_field("DISP",H1,AINSWORTH_LEGENDRE_BASE,3); CHKERRQ(ierr);
ierr = m_field.add_field("FLUX",HDIV,DEMKOWICZ_JACOBI_BASE,1); CHKERRQ(ierr);
// meshset consisting all entities in mesh
EntityHandle root_set = moab.get_root_set();
// add entities to field
ierr = m_field.add_ents_to_field_by_TETs(root_set,"DISP"); CHKERRQ(ierr);
ierr = m_field.add_ents_to_field_by_TETs(root_set,"FLUX"); CHKERRQ(ierr);
// set app. order (that is boring same order to all)
int order = 5;
ierr = m_field.set_field_order(root_set,MBTET,"DISP",order); CHKERRQ(ierr);
ierr = m_field.set_field_order(root_set,MBTET,"FLUX",order); CHKERRQ(ierr);
// build
ierr = m_field.build_fields(); CHKERRQ(ierr);
\endcode
Similarly, defining finite element set implement integration domain and build
internal data structures. Note, finite element structure is separated from
implementation. The same element can have several implementations which work on
some set of users data operators. Moreover, the same problem, defined on the
same field and data structures can be implemented in separate modules. Also,
several users modules exchange data by common MoFEM database, without knowledge
how other modules have been implemented, that enables simplified cooperation
between developers.

\subsection mofem_field_data_structure Internal field structure

You don't have to know how internal data structures works, like the driver of
the car, does not necessarily know how a spark plug works. So if you get bored,
you can skip this part.
\image html data_strutures_3.png "Fields data structures" width=800px

However sometimes is useful to know details when something goes wrong. The
objective is to have an extendable and flexible data structure which can manage
a wide range of approximations. In the same time have easy and fast access to
data structures, short set-up time and memory efficiency without redundancies.
This aim is realised by use boost multi-indices, aliased shared pointers and
vector sequences. See for example \ref MoFEM::NumeredDofEntity or \ref
MoFEM::DofEntity. Data are accessed by multi-indices, for example, defined in
\ref DofsMultiIndices.hpp, \ref EntsMultiIndices.hpp or \ref FieldMultiIndices.hpp.
The similar data structures are created for finite
elements and problems.









*/
