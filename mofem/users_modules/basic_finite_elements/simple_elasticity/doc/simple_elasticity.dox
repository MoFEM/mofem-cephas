/*! \page simple_elasticity_1 Simple elasticity


\section simple_elasticity_introduction Introduction

This tutorial presents in detail a number of basic Finite Element processes implemented in MoFEM through a user module implementation that solves a simple linear elastic problem.
The aim of this presentation is to facilitate new developers to familiarise themselves with certain practices and formulations regarding finite element processes and mesh information manipulation.
Readers are encouraged to read \ref general_data_structure, \ref hierarchical_approximation_1 and \ref hello_world_tut1 before starting the present tutorial.    
Initially, generation of a mesh is presented and then the module developed for this tutorial is dissected.
Finally, code run and post processing of the results are discussed.

\section simple_elasticity_problem The problem

The linear elastic problem modelled here is an orthogonal parallelepiped of dimensions \f$1.0\times1.0\times4.0 \,\,\rm{m}\f$, subjected to a uniformly distributed normal traction \f$\bar t\f$  on one face while its opposite face being simply supported.
The geometry of the problem is schematically presented in \ref Figure_1.
Boundary conditions are applied on the two faces with both edges equal to \f$1\,\,\rm m\f$.
Vertical displacements (along z direction) along the whole area of the bottom face are restricted.
To prevent rigid body motion, one of the bottom corners displacements along the x and y direction are restricted by the supports numbered 3 and 2 presented in \ref Figure_1, respectively.
Finally, displacements along y direction is restricted at a different corner of the bottom face by the support number 1 to prevent rigid body rotation.

\anchor Figure_1
\image html Problem.png "Figure 1: Geometry of the problem under consideration: orthogonal parallelepiped with dimensions of 1 m along x and y axis and 4 m along z axis that is simply supported on the bottom face and uniformly distributed normal tractions along the upper face." width = 300px

The boundary conditions where chosen to allow the body to deform freely on both horizontal directions. 
In this way, verification will be possible by checking the match between Poisson ratio recovered by the analysis results with the one used as input as a material parameter. 
Since only normal tractions are applied on the top face, no bending will occur along the faces parallel to the z axis and therefore no extra support is needed along the bottom edge connecting support 1 and 2.

Particular features associated to mesh input to solve the problem described here will be presented next.

\section simple_elasticity_mesh_input Mesh input

The user module presented here is associated with a specific mesh input.
Therefore, mesh generation process is briefly presented focusing only on the steps that are closely linked to the module implementation.
There is no intention to provide detail guidelines for using the mesh generator.
Mesh generators that can be used to run analyses in MoFEM are Salome, GMsh and Cubit.
Mesh features presented here are identical to those found in all three aforementioned software packages.

The mesh presented in \ref Figure_2 corresponds to the geometry of the problem illustrated in \ref Figure_1.
However, it should be noted that the mesh generator as well as MoFEM do not require a particular choice of units.
Instead, the user is responsible to be consisted with her/his own choice of units for any input parameter.


\anchor Figure_2
\image html CubitMesh1_1.png "Figure 2: Mesh geometry of an orthogonal parallelepiped of dimensions of 1x1x4 along x, y and z axis, respectively." width = 600px


To prescribe the boundary conditions for the generated mesh presented in \ref Figure_1, a number of blocks must be added to the mesh.
To prescribe the restriction on the vertical displacements on the bottom face and the normal traction on the upper face, surface blocks 1 and 3 are added on the corresponding faces as presented in \ref Figure_3 and \ref Figure_4, respectively.
Moreover, to assign the displacement restrictions represented by rollers 1, 2 and 3 in \ref Figure_1,  vertex blocks have to be added as presented in \ref Figure_5 and \ref Figure_6.



\anchor Figure_3
\image html Block1_1.png "Figure 3: Face block added to the bottom face of the orthogonal parallelepiped that will be used to restrain vertical displacements along that face." width = 600px

\anchor Figure_4
\image html Block3_1.png "Figure 4: Face block added to the top face of the orthogonal parallelepiped that will be used to apply uniformly distributed normal tractions along that face." width = 600px

\anchor Figure_5
\image html Block2_1.png "Figure 5: Vertex block added to one of the corners of the bottom face of the orthogonal parallelepiped that will be used to prescribe the boundary conditions represented by the rollers 2 and 3 presented in \ref Figure_1." width = 600px

\anchor Figure_6
\image html Block4_1.png "Figure 6: Vertex block added to one of the corners of the bottom face of the orthogonal parallelepiped that will be used to prescribe the boundary conditions represented by the roller 1 presented in \ref Figure_1." width = 600px

No specific boundary conditions are applied through the mesh generator.
To achieve prescription of boundary conditions, certain  mesh regions have to be numbered and characterised as ''Blocks''.
As explained earlier, block feature exists in Salome, GMsh and Cubit. 
Therefore, this feature is not restricted to the particular choice of mesh generator.
MoFEM user module executable will read the mesh input file and apply boundary conditions (see Sections \ref simple_elasticity_mesh_block and \ref ).

\section simple_elasticity_code_dissection Code dissection

\subsection simple_elasticity_header_files Header files

The header files included in the user module are presented below.


\code
#include <BasicFiniteElements.hpp>
#include <boost/program_options.hpp>

#include <Hooke.hpp>
#include <ElasticityNewOperator.hpp>
#include "../poisson/src/AuxPoissonFunctions.hpp"
\endcode

\subsection simple_elasticity_initialisation Initialisation

Initially, PETSc has to be initialised through the code line below

\code
  // Initialize PETSCc
  PetscInitialize(&argc, &argv, (char *)0, help);
\endcode

and now PETSc objects can now be declared.
As discussed in \ref general_data_structure article, PETSc objects are used to solve the large computational problem of the system of linear equations.  

To initialise the mesh database and an interface to interact with it, the following piece of code is included

\code
  // Create MoFEM database and link it to MoAB
  moab::Core mb_instance;//create database
  moab::Interface &moab = mb_instance; //create interface to database  
\endcode

MoFEM data base is initialised along with an interface object that will be used as a mean to interact with MoAB database   

\code
    MoFEM::Core core(moab); //MoFEM database
    MoFEM::Interface &m_field = core; //create interface to database
\endcode

This interaction is schematically presented as the interaction of level 1 and 2 in \ref Figure_7 on the right hand side.


\anchor Figure_7
\image html Interface.png "Figure 7: Data base interaction using interface objects Discrete Manager, m\_field and Simple interface." width = 600px

Moreover, the Discrete Manager that is the PETSc implementation within MoFEM has to be register to PETSc (schematically presented as interaction of levels 1 and 2 on the left hand side in \refFigure_7)

\code
    CHKERR DMRegister_MoFEM("DMMOFEM");
\endcode

Interaction of levels 2 and 3 is going to be described in Section \ref simple_elasticity_createFE.

To read data from the command line when executing the program the lines below are introduced

\code
    // Get command line options
    int order = 3;                    // default approximation order
    PetscBool flg_test = PETSC_FALSE; // true check if error is numerical error
    CHKERR PetscOptionsBegin(PETSC_COMM_WORLD, "", "SimpleElasticProblem", "none");

    // Set approximation order
    CHKERR PetscOptionsInt("-order", "approximation order", "", order, &order, PETSC_NULL);

    // Set testing (used by CTest)
    CHKERR PetscOptionsBool("-test", "if true is ctest", "", flg_test, &flg_test, PETSC_NULL);

    CHKERR PetscOptionsEnd();

\endcode

 

\code
    Vec global_error;
    CHKERR PoissonExample::AuxFunctions(m_field).createGhostVec(&global_error);
\endcode

\subsection simple_elasticity_createFE Creating Finite Element Instances

Pointers that point to ForcesAndSourcesCore struct are declared.
Each pointer is going to be used to create the finite elements to solve the problem under consideration.
 

\code
  boost::shared_ptr<ForcesAndSourcesCore> domain_lhs_fe;    ///< Volume element for the matrix
  boost::shared_ptr<ForcesAndSourcesCore> domain_rhs_fe;    ///< Volume element to assemble vector
  boost::shared_ptr<ForcesAndSourcesCore> domain_error;     ///< Volume element evaluate error
  boost::shared_ptr<ForcesAndSourcesCore> post_proc_volume; ///< Volume element to Post-process results
  boost::shared_ptr<ForcesAndSourcesCore> null
\endcode

A pointer to an object of type simple\_interface is declared.

\code
  Simple *simple_interface;
  CHKERR m_field.query_interface(simple_interface);
\endcode

The second line of code creates a link between simple\_interface  and m\_field interface (schematically presented in \ref Figure_7 as the interaction of levels 2 and 3 by the left hand side arrow). 
 
Struct simple\_interface has a number of functions implemented that allows the user to build and manipulate PETSc , MoAB core and MoFEM core data bases.
For instance, using the code below the mesh file is loaded and information of the mesh is passed to MoAB data base.

\code
  CHKERR simple_interface->getOptions();

  CHKERR simple_interface->loadFile();
\endcode

\subsection{Fields}

Fields of user's interest can be introduced to the MoAB database through simple\_interface object as presented below for the shape functions field  in our 3D domain. 

\code
  CHKERR simple_interface->addDomainField("U", H1, AINSWORTH_LEGENDRE_BASE, 3);

  CHKERR simple_interface->setFieldOrder("U", order); // to approximate function
\endcode

By using addDomainField function the name of the field chosen by the user can be introduced (in this case the name chosen is U).
The space chosen to operate is H1 and the type of shape functions is chosen through the key-word AINSWORTH\_LEGENDRE\_BASE are Legendre polynomials proposed by Ainsworth and Coyle.
Finally, the hard-coded number 3 determines the dimensions of the degrees of freedom related to each shape functions.
Here, this number is 3 since it is a displacement field in a 3D domain.
Should the unknown field be pressure, then the hard-coded number will be 1 instead of 3 since pressure always has one dimension.

Furthermore, the order of the approximation field is introduced through function setFieldOrder.
As explained earlier, the order of the approximated field can be chosen and the appropriate Hierarchical shape functions will be taken into account accordingly.

Other types of fields can also be introduced to MoAB database. 
For instance, an error field can be introduced to evaluate the error variance of the solution throughout the domain.
There will be explicit presentation of introduction of other fields in next tutorials.

\subsection simple_elasticity_mesh_block Mesh block handling

The blocks numbered 1, 2, 3 and 4 (defined in Section \ref simple_elasticity_mesh_input) will now be used to apply boundary conditions.
First, four Range objects (that are part of MoAB library) are declared for each block 

\code
Range fix_faces, pressure_faces, fix_nodes, fix_second_node;
\endcode

By using the MoFEM core interface m\_field, we loop through all meshSets in our MoFEM m\_field through the macro \_IT\_CUBITMESHSETS\_BY\_BCDATA\_TYPE\_FOR\_LOOP\_(m\_field, BLOCKSET, bit) as

\code
    for (_IT_CUBITMESHSETS_BY_BCDATA_TYPE_FOR_LOOP_(m_field, BLOCKSET, bit))
    {
      EntityHandle meshset = bit->getMeshset();
      int id = bit->getMeshsetId();

      if (id == 1)
      { //brick-faces

        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 2, fix_faces, true);
        
        Range adj_ents;
        CHKERR m_field.get_moab().get_adjacencies(fix_faces, 0, false, adj_ents, moab::Interface::UNION);
        
        CHKERR m_field.get_moab().get_adjacencies(fix_faces, 1, false, adj_ents, moab::Interface::UNION);
        
        fix_faces.merge(adj_ents);
      }
      else if (id == 2)
      { //node(s)
        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 0, fix_nodes, true);
      }
      else if (id == 3)
      { //brick pressure faces
        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 2, pressure_faces, true);
      }
      else if (id == 4)
      { //restrained second node in y direction
        CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 0, fix_second_node, true);
      }
      else
      {
        SETERRQ(PETSC_COMM_WORLD, MOFEM_DATA_INCONSISTENCY, "Unknown blockset");
      }
    }
\endcode

the identity of each meshSet is found as 

\code
  EntityHandle meshset = bit->getMeshset();
  int id = bit->getMeshsetId();
\endcode

the id values correspond to the block numbering presented in Section \ref simple_elasticity_mesh_input.
When the value of id is equal to 1, 2, 3 or 4 boundary conditions are prescribed following the schematic in \ref Figure_1.

For id equal to 1, the meshSet is copied to object fix\_faces through the MoAB function

\code
 CHKERR m_field.get_moab().get_entities_by_dimension(meshset, 2, fix_faces, true);
\endcode

were the hard coded number 2, refers to the type of entity under consideration which in this case is a face.
Numbers 0, 1 and 3 correspond to vertices, edges and volumes, respectively.

Since we are interested in prescribing all degrees of freedom lying along the faces, we need to copy all corresponding entities i.e. vertices and edges, to the fix_faces object.
This can be achieved by using the MoAB function get\_adjacencies that provides information for the entities adjacent to the input meshSet (in this case fix\_faces).
To implement this, another Range object with name adj\_ents is created where all the information of the adjacent entities are going to be copied as presented below.

\code
  Range adj_ents;
  CHKERR m_field.get_moab().get_adjacencies(fix_faces, 0, false, adj_ents, moab::Interface::UNION);
  
  CHKERR m_field.get_moab().get_adjacencies(fix_faces, 1, false, adj_ents, moab::Interface::UNION);
\endcode

Similar to the case  of function get\_entities\_by\_dimension, hard coded integers indicate the type of entities under consideration.
Thereafter, all information passed to the new Range object adj\_ents is copied to fix\_faces object through the MoAB function merge as 

\code
fix_faces.merge(adj_ents);
\endcode

For the vertex type meshSets, no adjacencies are needed since only the degrees of freedom associated to each block is going to be prescribed.
Therefore, invoking get\_entities\_by\_dimension function is sufficient.

For the case of the block of the upper face (id = 3), only the degrees of freedom associated to the face are needed.
Since the traction is uniform and normal to the upper surface, it can be implemented as pressure and therefore its implementation requires only degrees of freedom associated to the face as presented in section ``Application of boundary conditions''.

Finally, the rest of blocks are of vertex type and there is no need to search for adjacencies since only the degrees of freedom at those points are needed to be prescribed.


\subsection{MoFEM Finite Element Method work flow}

All problems tackled by user modules proceed with the same workflow for construction of the FEM solution. 
The workflow implemented in MoFEM is schematically presented in \ref Figure_8 and consists of Definition, Build and Assemble processes.

\anchor Figure_8
\image html WorkFlow.png "Figure 8: MoFEM work flow." width = 200px

Definition process encompasses creation of stencils of finite elements, fields and problems that are going to be used for the problem solution.

Field stencils include name, dimension and order and are defined as

\code
   CHKERR simple_interface->addDomainField("U", H1, AINSWORTH_LEGENDRE_BASE, 3);

   CHKERR simple_interface->setFieldOrder("U", order);
\endcode

For the elements, the stencil includes element's name, dimension, type of fields that are going to be approximated in this element and the location of the element that the fields operate (volume, boundary or skeleton).
Each kind of element used needs a different kind of stencil to be defined.

\code
    CHKERR simple_interface->defineFiniteElements();
\endcode

For reasons that will be apparent in Section \ref simple_elasticity_op_pressure, we will apply traction boundary conditions through a new element.
Since this element is unknown to the simple interface structure we need to explicitly define the element to be included in m\_field

\code
    // Add pressure element
    CHKERR m_field.add_finite_element("PRESSURE");
    
    CHKERR m_field.modify_finite_element_add_field_row("PRESSURE", "U");
    
    CHKERR m_field.modify_finite_element_add_field_col("PRESSURE", "U");
    
    CHKERR m_field.modify_finite_element_add_field_data("PRESSURE", "U");
\endcode

Initially, the new finite element type with name is added to MoFEM core database through the function add\_finite_element(``PRESSURE''), where the string ``PRESSURE'' used as input is the name that we chose to call the new element.
Then, the row and col field information of the ``PRESSURE'' element are set to be those of ``U'' type.
Furthermore, the list of fields that are associated with ``PRESSURE'' element listed in the elements data is then set to be only the ``U'' type field.
In a more complicated case, more than one fields can be added to the data, row and col structures of a finite element.


Similarly, definition of each problem stencil consists of problem's name and the stencils of the various elements previously presented and are defined using the code lines below

\code
    CHKERR simple_interface->defineProblem();
\endcode

Before defining a problem, all kinds of elements used have to be previously defined.

\section simple_elastic_UDO_FE Introduction of user defined finite element

\subsection simple_elastic_DMM DMMoFEM

The new ``PRESSURE'' finite element has to be explicitly added to DMMoFEM since it was not created through simple\_interface.
Hence, a DM object is declared and it is set to point to the DMMoFEM create by the interface as

\code
  DM dm;
  CHKERR simple_interface->getDM(&dm);
\endcode

and then the ``PRESSURE'' finite element is going to be added to DMMoFEM as

\code
  CHKERR DMMoFEMAddElement(dm, "PRESSURE");
\endcode

This is schematically illustrated as the interaction of levels 2 and 3 on the left hand side of \ref Figure_7 .
Then all information introduced to DMMoFEM manager is partitioned

\code
  CHKERR DMMoFEMSetIsPartitioned(dm, PETSC_TRUE);
\endcode

This has to be explicitly defined in order to be able to solve the problem in parallel computing fashion.

\subsection simple_elastic_build Build

Then, fields and finite elements declared through simple\_interface are built (second stage presented in \ref Figure_8).

\code
    CHKERR simple_interface->buildFields();

    CHKERR simple_interface->buildFiniteElements();
\endcode

First, the dimension and order of fields according to the specific input chosen is added to the field.
In this case, the approximation field of Hierarchic shape functions of Hainsworth and Coyle Legendre polynomials type of order 3 and dimension 3 will be set to the field.
Thereafter, finite elements are built i.e. entities of the finite elements are linked to the field components that were previously built and the order of approximation is set to each entity.


\code
    CHKERR m_field.add_ents_to_finite_element_by_dim(0, simple_interface->getDim(), simple_interface->getDomainFEName(), true);

    CHKERR m_field.build_finite_elements(simple_interface->getDomainFEName());
\endcode

entities associated with the user defined ``PRESSURE'' finite element have to be explicitly added to the finite element

\code
    CHKERR m_field.add_ents_to_finite_element_by_dim(pressure_faces, 2, "PRESSURE");

    CHKERR m_field.build_finite_elements("PRESSURE", &pressure_faces);
\endcode

Then to build all information regarding the element connectivities, and fields associated to element entities into MoFEM core, the function below is invoked. 

\code
    CHKERR simple_interface->buildProblem();
\endcode

Moreover, to create stiffness matrices and apply boundary conditions we will need to create vectors of finite elements and attach User Defined Operators (UDOs).

For the stiffness matrix evaluation a new shared pointer elastic\_fe is instantiated to build elastic finite elements and a UDO is pushed to the elastic finite elements

\code
    boost::shared_ptr<VolumeElementForcesAndSourcesCore> elastic_fe(new VolumeElementForcesAndSourcesCore(m_field));
    elastic_fe->getOpPtrVector().push_back(new OpK());
\endcode

schematically presented in \ref Figure_9.

\anchor Figure_9
\image html OperatorPush.png "Figure 9: Schematic representation inclusion process of User Defined Operators to finite element data structure." width = 600px


It is important to state that each instance of the structs of elastic finite elements pointed by shared pointed elastic\_fe carries with it the operator OpK().

To apply the traction boundary conditions, shared pointer pressure\_fe is instantiated and then the operator OpPressure is attached to it to prescribe the traction boundary conditions.

\code
    // push operators to elastic_fe
    boost::shared_ptr<FaceElementForcesAndSourcesCore> pressure_fe(new FaceElementForcesAndSourcesCore(m_field));
    pressure_fe->getOpPtrVector().push_back(new OpPressure());
\endcode

Finally, to prescribe the Dirichlet boundary conditions, the shared pointer fix\_dofs\_fe is instantiated as a ApplyDirichletBc that is inherited by FEMethod type (which lies within the structs that are in the finite elements family within MoFEM) as

\code
    boost::shared_ptr<FEMethod> fix_dofs_fe(new ApplyDirichletBc(fix_faces, fix_nodes, fix_second_node));
\endcode

The Ranges of fix\_faces, fix\_nodes and fix\_second\_node are given as input to the constructor of ApplyDirichletBc to provide the mesh information regarding the location of the degrees of freedom that will be prescribed.

Implementation of OpK(), opPressure and fix_dofs_fe is presented in Section \ref simple_elastic_UDO.
A more general implementation for application of boundary conditions will be presented in future tutorials.


\section simple_elastic_solve_problem Solving the problem

In this example the KSP solver provided by PETSc is used.
Initially, finite elements are pushed to the discrete manager and set KSP operators for assembling the stiffness matrix.

\code
// Set operators for KSP solver
    ierr = DMMoFEMKSPSetComputeOperators(
        dm, simple_interface->getDomainFEName(), elastic_fe, nullFE, nullFE);
\endcode

Then, right hand side vector is evaluated and KSP operators are set to handle it. 

\code
    CHKERR DMMoFEMKSPSetComputeRHS(
        dm, "PRESSURE", pressure_fe, nullFE, nullFE);
\endcode

Thereafter, stiffness matrix A, vector of degrees of freedom x and right hand side vector f are declared and associated to the Discrete Manager DM  

\code
    Mat A;
    Vec x, f;

    CHKERR DMCreateMatrix(dm, &A);

    CHKERR DMCreateGlobalVector(dm, &x);

    CHKERR VecDuplicate(x, &f);
\endcode

Thereafter, members of finite elements structs are set to point to the aforementioned objects

\code
    fix_dofs_fe->ksp_B = A;
    fix_dofs_fe->ksp_f = f;
    elastic_fe->ksp_B = A;
    pressure_fe->ksp_f = f;
\endcode


Now all finite elements are prepared to be looped (all operators have been pushed to the elements and their members point to the structural problem A, f and x objects) in order to Assembly the problem, i.e. the third part of the work flow presented in \ref Figure_8.
Now, each element created is looped to compute and assemble the stiffness matrix and left hand and right hand vectors as 

\code
    CHKERR DMoFEMLoopFiniteElements(dm, simple_interface->getDomainFEName(), elastic_fe);

    CHKERR DMoFEMLoopFiniteElements(dm, "PRESSURE", pressure_fe);
\endcode

Furthermore, the part of the prescribed degrees of freedom are assembled in the left hand side vector through
\code
//This is done because only post processor is implemented in the ApplyDirichletBc struct
    CHKERR DMoFEMPostProcessFiniteElements(dm, fix_dofs_fe.get());
\endcode

Implementation of UDOs associated with pressure\_fe and fix\_dof\_fe are going to be presented in Section \ref simple_elastic_UDO.


At this point matrix and two vectors have been assembled and we can now solve our system of linear equations.
Solver is declared first and then connected to the MoFEM core as

\code
    KSP solver;

    CHKERR KSPCreate(PETSC_COMM_WORLD, &solver);
\endcode

 The solver object operators have to be prepared 

\code
    CHKERR KSPSetFromOptions(solver);

    CHKERR KSPSetOperators(solver, A, A);

    CHKERR KSPSetUp(solver);
\endcode

and finally the problem is solved

\code
    CHKERR KSPSolve(solver, f, x);
\endcode

 the results are written in left hand side vector x

\code
    VecView(x, PETSC_VIEWER_STDOUT_WORLD);
\endcode

and all values of degrees of freedom in x are mapped onto mesh entities

\code
    // save solution in vector x on mesh
    CHKERR DMoFEMMeshToGlobalVector(dm, x, INSERT_VALUES, SCATTER_REVERSE);
\endcode

\section simple_elastic_post_processing Post processing

To post process numerical results, initially a post processor object of type PostProcVolumeOnRefinedMesh has to be created based on MoAB database

\code
// Set up post-procesor. It is some generic implementation of finite element.
    PostProcVolumeOnRefinedMesh post_proc(m_field);
\endcode

Thereafter, information of the problem solution is passed to the post processor as  

\code
    // Add operators to the elements, strating with some generic
    CHKERR post_proc.generateReferenceElementMesh();

    CHKERR post_proc.addFieldValuesPostProc("U");

    CHKERR post_proc.addFieldValuesGradientPostProc("U");

    CHKERR DMoFEMLoopFiniteElements(dm, simple_interface->getDomainFEName().c_str(), &post_proc);
\endcode

where initially a reference mesh is created is created, then field values are added and finally all information related to finite elements such ass stain and stresses are added into the post processor.

Finally, all information introduced to the post processor object is written to an output file (in this case named out.h5m) as presented below

\code
    CHKERR post_proc.writeFile("out.h5m");
\endcode


\section simple_elastic_clean_memory Clean memory

All dynamic memory objects A, x, f and DM that were created have to be destroyed as presented below

\code
  CHKERR MatDestroy(&A);

  CHKERR VecDestroy(&x);

  CHKERR VecDestroy(&f);

  CHKERR DMDestroy(&dm);
\endcode

 to free the heap memory and prevent any memory leaks.

\section simple_elastic_UDO User Defined Operators (UDOs)

\subsection simple_elastic_element_stiffness Element stiffness matrix

In structural computational mechanics, the most common relationship to evaluate the stiffness matrix for an element is given by
 
\f[
\begin{equation}
{\mathbf {K}^{e}} = 
\int_{\Omega^e} { \mathbf{B}}^{\rm T} {\mathbf {D}} {\mathbf{B}} \, {d\Omega^e}
\label{eq:StiffnessIntegral}
\end{equation}
\f]

where \f${\Omega^e}\f$ is the element volume, \f${\mathbf {D}}\f$ is the elastic material stiffness matrix and \f${\mathbf{B}}\f$ is the matrix containing the first derivatives of the element shape functions as presented in Hierarchical approach tutorial as

\f[
\begin{equation}
\begin{split}
{\mathbf {B}} = {\mathbf {\nabla N}^e} = \left[
\begin{array}{c}
\dfrac{\partial}{\partial x}\\
\dfrac{\partial}{\partial y}\\
\dfrac{\partial}{\partial z}\\
\end{array} \right]
\left[ 
 \begin{array}{c}
{\mathbf {N}^e_{\textrm ver}} \\
{\mathbf {N}^e_{\textrm edge}} \\
{\mathbf {N}^e_{\textrm face}} \\
{\mathbf {N}^e_{\textrm vol}} \\
\end{array} \right] = \left[
 \begin{array}{cccc}
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial x} & \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial x} 
& \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial x} & \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial x} \\ 
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial y} & \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial y} 
& \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial y} & \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial y}\\ 
\dfrac{\partial {\mathbf {N}^e_{\textrm ver}} }{\partial z} & \dfrac{\partial {\mathbf {N}^e_{\textrm edge}} }{\partial z} 
& \dfrac{\partial {\mathbf {N}^e_{\textrm face}} }{\partial z} & \dfrac{\partial {\mathbf {N}^e_{\textrm vol}} }{\partial z} \\
\end{array} \right] = \\
= \left[ 
 \begin{array}{cccc}
{\mathbf {\nabla N}^e_{\textrm ver}} & {\mathbf {\nabla N}^e_{\textrm edge}} & {\mathbf {\nabla N}^e_{\textrm face}} & {\mathbf {\nabla N}^e_{\textrm vol}}
\end{array} \right] \hspace{2.5cm} 
\end{split}
\label{eq:NablaShapeSimpleElastiic}
\end{equation}
\f]

In the continuation of this tutorial, evaluation of the stiffness matrix at each element, and consequently in each Gauss point, is going to be performed through calculation of \f${\mathbf{B}}\f$.


\subsection simple_elasticisty_OpK OpK()

The operator called OpK is implemented as a struct inhereting struct VolumeElementForcesAndSourcesCore::UserDataOperator

\code
struct OpK : public VolumeElementForcesAndSourcesCore::UserDataOperator
\endcode

Struct's public members are 

\code
  MatrixDouble rowB;
  MatrixDouble colB;
  MatrixDouble CB;
  MatrixDouble K, transK;

  MatrixDouble D;
  double yOung;
  double pOisson;
  double coefficient;
\endcode

The first four lines encompass the declaration of matrices used for the calculation of the elements striffness matrix as presented in Section \ref simple_elastic_element_stiffness.
The next three variables are associated to the material stiffness matrix where D is used to evaluate the elastic material stiffness matrix, yOung is the Young's modulus and pOisson is Poisson's ratio.

When the struct's constructor is invoked 

\code
 OpK(bool symm = true) : VolumeElementForcesAndSourcesCore::UserDataOperator("U", "U", OPROWCOL, symm)
  {
  pOisson = 0.1;
  yOung = 10;
  yOung /= ((1 + pOisson) * (1 - 2 * pOisson));
  D.resize(6, 6, false);
  D.clear();

  D(0, 0) = 1 - pOisson;
  D(1, 1) = 1 - pOisson;
  D(2, 2) = 1 - pOisson;
  D(3, 3) = 0.5 * (1 - 2 * pOisson);
  D(4, 4) = 0.5 * (1 - 2 * pOisson);
  D(5, 5) = 0.5 * (1 - 2 * pOisson);

  D(0, 1) = pOisson;
  D(0, 2) = pOisson;
  D(1, 0) = pOisson;

  D(1, 2) = pOisson;
  D(2, 0) = pOisson;
  D(2, 1) = pOisson;

  D *= yOung;
  }
\endcode

where the Elastic stiffness matrix is evaluated

When solving the problem, as presented in Section \ref simple_elastic_solve_problem, all finite elements are looped where this loop invokes the doWork method of each operator of the finite element.
The doWork method of operator OpK is presented below

\code
MoFEMErrorCode doWork(
      int row_side, int col_side,
      EntityType row_type, EntityType col_type,
      DataForcesAndSourcesCore::EntData &row_data, DataForcesAndSourcesCore::EntData &col_data)
  {
    MoFEMFunctionBeginHot;
    // get number of dofs on row
    nbRows = row_data.getIndices().size();
    // if no dofs on row, exit that work, nothing to do here
    if (!nbRows)
      MoFEMFunctionReturnHot(0);
    // get number of dofs on column
    nbCols = col_data.getIndices().size();
    // if no dofs on Columbia, exit nothing to do here
    if (!nbCols)
      MoFEMFunctionReturnHot(0);
    // get number of integration points
    nbIntegrationPts = getGaussPts().size2();
    // chekk if entity block is on matrix diagonal
    if (
        row_side == col_side &&
        row_type == col_type)
    {
      isDiag = true; // yes, it is
    }
    else
    {
      isDiag = false;
    }
    // integrate local matrix for entity block
    CHKERR iNtegrate(row_data, col_data);
    
    // asseble local matrix
    CHKERR aSsemble(row_data, col_data);
    
    MoFEMFunctionReturnHot(0);
  }
\endcode


The element's column and row data structures as described in ``Hierarchic approximation'' tutorial are passed to this function as col\_type and row\_type respectively.
The number of degrees of freedom associated to each structure (which are equal to the length of the column and row) is then passed to variables nbCols and nbRows and checked that they are non-zero

\code
// get number of dofs on row
    nbRows = row_data.getIndices().size();
    // if no dofs on row, exit that work, nothing to do here
    if (!nbRows)
      MoFEMFunctionReturnHot(0);
    // get number of dofs on column
    nbCols = col_data.getIndices().size();
    // if no dofs on Columbia, exit nothing to do here
    if (!nbCols)
      MoFEMFunctionReturnHot(0);
\endcode

Thereafter, integration presented in \f$\eqref {eq:StiffnessIntegral}\f$ to evaluate element's stiffness matrix and the its assembly to the element's row and column data structures is performed by invoking iNtegrate and aSsemble functions 

\code
    // integrate local matrix for entity block
    CHKERR iNtegrate(row_data, col_data);

    // asseble local matrix
    CHKERR aSsemble(row_data, col_data);
\endcode


Lets first see the iNtegrate implementation that performs the two inner loops described in Section \ref hierarchical_approximation_data_structures of \ref hierarchical_approximation_1 tutorial

\code
virtual MoFEMErrorCode iNtegrate(
      DataForcesAndSourcesCore::EntData &row_data, DataForcesAndSourcesCore::EntData &col_data)
  {
    MoFEMFunctionBeginHot;

    int nb_dofs_row = row_data.getFieldData().size();
    if (nb_dofs_row == 0)
      MoFEMFunctionReturnHot(0);
    int nb_dofs_col = col_data.getFieldData().size();
    if (nb_dofs_col == 0)
      MoFEMFunctionReturnHot(0);

    K.resize(nb_dofs_row, nb_dofs_col, false);
    K.clear();
    CB.resize(6, nb_dofs_col, false);

    for (int gg = 0; gg != nbIntegrationPts; gg++)
    {
      // get element volume
      // get integration weight
      double val = getVolume() * getGaussPts()(3, gg);

      const MatrixAdaptor &diffN_row = row_data.getDiffN(gg, nb_dofs_row / 3);
      const MatrixAdaptor &diffN_col = col_data.getDiffN(gg, nb_dofs_col / 3);

      ierr = makeB(diffN_row, rowB);
      CHKERRQ(ierr);

      ierr = makeB(diffN_col, colB);
      CHKERRQ(ierr);

      noalias(CB) = prod(D, colB);
      noalias(K) += val * prod(trans(rowB), CB);
    }
    MoFEMFunctionReturnHot(0);
  }
\endcode

after the element's lengths of row and columns are passed to nb\_dofs\_row and nb\_dofs\_columns and checked to be non-zero, memory for the element's stiffness matrix K that is allocated so that the number of rows equal to the number of degrees of freedom stored in the row data structure. Similarly the number of columns of K matrix is equal to the degrees of freedom stored in the column data structure as can be undestrood by inspection of equation \f$\eqref {eq:FullStiffness} \f$ in ``Hierachical Approach'' tutorial.
Finally, data stored in K is set equal to zero

\code
 K.resize(nb_dofs_row, nb_dofs_col, false);
 K.clear();
\endcode
 
Then, we allocate memory for the CB matrix used to evaluate K matrix according to \f$\eqref{eq:StiffnessIntegral}\f$.

\code
  CB.resize(6, nb_dofs_col, false);
\endcode

The above code line resizes CB matrix to have 6 rows while keeping the number of columns the same as The stiffness matrix.
This is done since the material stiffness matrix is \f$6\times 6\f$ and we know there is a dimention matching between the matrices according to (10) in ``Hierachical Approach'' tutorial.

Then, the integration process is performed for each gauss point associated to the finite element under consideration

\code
 for (int gg = 0; gg != nbIntegrationPts; gg++)
\endcode

Within the loop, initially the element's volume is evaluated

\code
 double val = getVolume() * getGaussPts()(3, gg);
\endcode
 
We can now have a closer look in makeB function that is used to evaluate the B matrix and its transpose

\code
MoFEMErrorCode makeB(const MatrixAdaptor &diffN,
                       MatrixDouble &B)
  {
    MoFEMFunctionBeginHot;

    unsigned int nb_dofs = diffN.size1();
    B.resize(6, 3 * nb_dofs, false);
    B.clear();
    for (unsigned int dd = 0; dd < nb_dofs; dd++)
    {
      const double diff[] = {
          diffN(dd, 0), diffN(dd, 1), diffN(dd, 2)};
      const int dd3 = 3 * dd;
      for (int rr = 0; rr < 3; rr++)
      {
        B(rr, dd3 + rr) = diff[rr];
      }
      // gamma_xy
      B(3, dd3 + 0) = diff[1];
      B(3, dd3 + 1) = diff[0];
      // gamma_yz
      B(4, dd3 + 1) = diff[2];
      B(4, dd3 + 2) = diff[1];
      // gamma_xz
      B(5, dd3 + 0) = diff[2];
      B(5, dd3 + 2) = diff[0];
    }

    MoFEMFunctionReturnHot(0);
  }
\endcode

where initially the number of degrees of freedom associated to the element is evaluated and then th B matrix is declared and resized to have number of columns equal to the number of degrees of freedom

\code
  unsigned int nb_dofs = 3 * diffN.size1();
    B.resize(6, nb_dofs, false);
    B.clear();
\endcode

the number of degrees of freedom is equal to three times the number of shape function gradients since they operate in three dimensions (they have x, y and z components).
If the unknown field would be pressure, the number of degrees of freedom would be equal to the number of shape function gradients. 

\subsection simple_elasticity_op_pressure OpPressure

The operator created for the ``PRESSURE'' finite element that is used to evaluate and assign Neuman boundary conditions according to (12) presented in ``Hierarchical Approach'' tutorial will be presented in detail.
The operator is the struct presented below 

\code
  OpPressure(const double pressure_val = 1) :

                                              MoFEM::FaceElementForcesAndSourcesCore::UserDataOperator("U", OPROW),
                                              pressureVal(pressure_val)
  {
  }
  //  virtual ~OpPressure();

  VectorDouble nF;

  FTensor::Index<'i', 3> i;

  MoFEMErrorCode doWork(int side, EntityType type, DataForcesAndSourcesCore::EntData &data)
  {

    MoFEMFunctionBeginHot;

    const int nb_dofs = data.getIndices().size();
    if (nb_dofs == 0)
      MoFEMFunctionReturnHot(0);

    nF.resize(nb_dofs, false);
    nF.clear();

    const int nb_gauss_pts = data.getN().size1();
    FTensor::Tensor1<double *, 3> t_normal = getTensor1Normal();
    FTensor::Tensor0<double *> t_base = data.getFTensor0N();

    for (int gg = 0; gg != nb_gauss_pts; gg++)
    {
      double w = 0.5 * getGaussPts()(2, gg);
      FTensor::Tensor1<double *, 3> t_nf(&nF[0], &nF[1], &nF[2], 3);
      for (int bb = 0; bb != nb_dofs / 3; bb++)
      {
        t_nf(i) += (w * pressureVal * t_base) * t_normal(i);
        ++t_nf;
        ++t_base;
      }
    }

    CHKERR VecSetValues(
        getFEMethod()->ksp_f, nb_dofs, &data.getIndices()[0], &nF[0], ADD_VALUES);
  
    MoFEMFunctionReturnHot(0);
  }
};
\endcode

Initially, vector nF that will contain the boundary condition forces is declared and index i is defined to be used to perform compact operations later discussed
 
\code
  VectorDouble nF;

  FTensor::Index<'i', 3> i;

    if (nb_dofs == 0)
    MoFEMFunctionReturnHot(0);
\endcode

The evaluation of boundary conditions for each element that are applied is performed within the doWork function.
The number of degrees of freedom is initially passed to nb\_dofs that is used to aproprietly resize vector nF.

\code
    nF.resize(nb_dofs, false);
    nF.clear();
\endcode


Thereafter, the number of gauss points associated to the triangular element is assigned to variable nb\_gauss\_pts

\code
    const int nb_gauss_pts = data.getN().size1();
\endcode

the normal to the face is passed to t\_normal variable

\code
    FTensor::Tensor1<double *, 3> t_normal = getTensor1Normal();
\endcode 

Vector t\_normal has 3 component (one for each global axis). 
Its magnitude is equal to the double of the area of the triangualr face since getTensor1Norma() function returns the vector evaluated by the cross product of the vectors having a common origin on one of the faces vertex and their non-coinciding ends located at the other two vertices.
This product is the area defined by the parallelogram rule.

Furthermore, t\_base vector containing the element's shape functions is initialised 

\code 
  FTensor::Tensor0<double *> t_base = data.getFTensor0N();
\endcode 

Then, the loop over all gauss points is performed to evaluate the area integral presented in (12) in ``Hierarchical Approximation'' tutorial

\code 
    for (int gg = 0; gg != nb_gauss_pts; gg++)
    {
      double w = getGaussPts()(2, gg);
      FTensor::Tensor1<double *, 3> t_nf(&nF[0], &nF[1], &nF[2], 3);
      for (int bb = 0; bb != nb_dofs / 3; bb++)
      {
        t_nf(i) += (w * pressureVal * t_base) * t_normal(i);
        ++t_nf;
        ++t_base;
      }
    }
\endcode 
  
In the loop, initially the weight of the gauss point is assigned to w

\code 
double w = getGaussPts()(2, gg);
\endcode 

then t\_nF that is a pointer to a vector is initialised in a fashion that points to a piece of memory containing three contiguous double values that are in this case the first three elements of the boundary condition vector nF.

Since the t\_nF presents this structure of three contiguous elements pointed by each pointer value, we only need to loop over a third of the number of degrees of freedom.

\code 
  for (int bb = 0; bb != nb_dofs / 3; bb++)
\endcode 
      
and the within the loop for each t\_nF value, the corresponding block of three members of nF can be evaluated as

\code
 t_nf(i) += (w * pressureVal * t_base) * 0.5 * t_normal(i); 
\endcode 

Index i in the last line operates the for each part of the three elements of nF.
So in the first instance, where bb = 0, nF[0], nF[1] and nF[2] are evaluated.

Thereafter, pointers t\_nf and t\_base are increased, and now they are pointing to the next corresponding bit of memory.

\code
        ++t_nf;
        ++t_base;
\endcode 

In the second instance, where bb = 1, t\_nf(i) operates in the next three elements of nF, i.e. nF[3], nF[4], nF[5] are evaluated and so on.

Each member of nF contains the surface integral presented in (12) of ``Hierarchical Approxiamtion'' associated to the the corresponding to gauss point gg and degree of freedom 3*bb.
The product that is assigned to t\_nf(i) involves multiplication of weight w of gauss point gg, the uniformly distributed traction is a scalar pressureVal times the shape function t\_base of degrees of freedom encapsulated in bb, times half the vector normal to the surface.
The halving of the vector is done to recover the face area that is the double of the vector magnitude as describe previously.

Finally, the values passed to vector nF are then copied to the right hand side vector ksp\_f that points to vector f presented in Section \ref simple_elastic_solve_problem used for the solution of the system of linear equations.

\code
ierr = VecSetValues(
        getFEMethod()->ksp_f, nb_dofs, &data.getIndices()[0], &nF[0], ADD_VALUES);
\endcode 
     
\subsection simple_elasticity_apply_Dir_BC ApplyDirichletBc

The struct implemented to apply homogeneous Dirichlet boundary conditions named ApplyDirichletBc is presented below

\code
struct ApplyDirichletBc : public MoFEM::FEMethod {
 
   Range fixFaces, fixNodes, fixSecondNode;
 
   ApplyDirichletBc(const Range &fix_faces, const Range &fix_nodes,
                    const Range &fix_second_node)
       : MoFEM::FEMethod(), fixFaces(fix_faces), fixNodes(fix_nodes),
         fixSecondNode(fix_second_node) {
     // constructor
   }
 
   MoFEMErrorCode postProcess() {
 
     MoFEMFunctionBeginHot;
     std::set<int> set_fix_dofs;
     cerr << fixFaces << endl;
     cerr << fixNodes << endl;
     cerr << fixSecondNode << endl;
 
     for (_IT_NUMEREDDOF_ROW_FOR_LOOP_(problemPtr, dit)) {
       if (dit->get()->getDofCoeffIdx() == 2) {
         if (fixFaces.find(dit->get()->getEnt()) != fixFaces.end()) {
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixSecondNode.find(dit->get()->getEnt()) != fixSecondNode.end()) {
         if (dit->get()->getDofCoeffIdx() == 1) {
           printf("The extra node \n");
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixNodes.find(dit->get()->getEnt()) != fixNodes.end()) {
         set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
       }
     }
 
     std::vector<int> fix_dofs(set_fix_dofs.size());
 
     std::copy(set_fix_dofs.begin(), set_fix_dofs.end(), fix_dofs.begin());
 
     CHKERR MatAssemblyBegin(ksp_B, MAT_FINAL_ASSEMBLY);

     CHKERR MatAssemblyEnd(ksp_B, MAT_FINAL_ASSEMBLY);

     CHKERR VecAssemblyBegin(ksp_f);

     CHKERR VecAssemblyEnd(ksp_f);
 
     Vec x;
     
     CHKERR VecDuplicate(ksp_f, &x);

     CHKERR VecZeroEntries(x);

     CHKERR
         MatZeroRowsColumns(ksp_B, fix_dofs.size(), &fix_dofs[0], 1, x, ksp_f);

     CHKERR VecDestroy(&x);
 
     MoFEMFunctionReturnHot(0);
   }
 };
 \endcode

Entities that were previously handled in Section \ref simple_elasticity_mesh_block are assigned through the constructor in public variables fixFaces, fixNodes, fixSecondNode

\code
   Range fixFaces, fixNodes, fixSecondNode;
 
   ApplyDirichletBc(const Range &fix_faces, const Range &fix_nodes,
                    const Range &fix_second_node)
       : MoFEM::FEMethod(), fixFaces(fix_faces), fixNodes(fix_nodes),
         fixSecondNode(fix_second_node) {
     // constructor
   }
\endcode

The homogeneous boundary conditions are then implemented in postProcess() function.
Initially, a loop over degrees of freedom is performed through macro ``for (\_IT\_NUMEREDDOF\_ROW\_FOR\_LOOP\_(problemPtr, dit))''.
Within the loop, the degrees of freedom corresponding to the entities passed to the public variables of the struct are inserted to vector of integers set\_fix\_dofs through insert function

\code
MoFEMFunctionBeginHot;
     std::set<int> set_fix_dofs;
     cerr << fixFaces << endl;
     cerr << fixNodes << endl;
     cerr << fixSecondNode << endl;

     for (_IT_NUMEREDDOF_ROW_FOR_LOOP_(problemPtr, dit)) {
       if (dit->get()->getDofCoeffIdx() == 2) {
         if (fixFaces.find(dit->get()->getEnt()) != fixFaces.end()) {
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixSecondNode.find(dit->get()->getEnt()) != fixSecondNode.end()) {
         if (dit->get()->getDofCoeffIdx() == 1) {
           printf("The extra node \n");
           set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
         }
       }
 
       if (fixNodes.find(dit->get()->getEnt()) != fixNodes.end()) {
         set_fix_dofs.insert(dit->get()->getPetscGlobalDofIdx());
       }
     }
\endcode

then this data is pass to a new vector of integers fix\_dofs 

\code
std::vector<int> fix_dofs(set_fix_dofs.size());
 
std::copy(set_fix_dofs.begin(), set_fix_dofs.end(), fix_dofs.begin());
\endcode

Thereafter, the stiffness matrix ksp\_B and right hand side vector ksp\_f structures are constructed   

\code
     CHKERR MatAssemblyBegin(ksp_B, MAT_FINAL_ASSEMBLY);

     CHKERR MatAssemblyEnd(ksp_B, MAT_FINAL_ASSEMBLY);

     CHKERR VecAssemblyBegin(ksp_f);

     CHKERR VecAssemblyEnd(ksp_f);
 \endcode

and the left hand side vector x is constructed by copying  ksp\_f to x and subsequently zeroing it

\code
Vec x;
     
     CHKERR VecDuplicate(ksp_f, &x);

     CHKERR VecZeroEntries(x);
\endcode


Invoking function MatZeroRowsColumns the columns and rows corresponding to the prescribed degrees of freedom stored in fix\_dofs and the diagonal element is set to unity and the corresponding degrees of freedom in vector x are set to zero.

\code
CHKERR   MatZeroRowsColumns(ksp_B, fix_dofs.size(), &fix_dofs[0], 1, x, ksp_f);
\endcode

finally the memory allocated for vector x is freed

\code
CHKERR VecDestroy(&x);
\endcode

\section simple_elasticity_prog_run Running the program

To run the code one should change directory to 

\code
cd $HOME/mofem_installation//users_modules/basic_finite_elements/simple_elasticity
\endcode

Then run the command

\code
./simple_elasticity -file_name help.h5m -ksp_type gmres -pc_type lu -pc_factor_mat_solver_package mumps -ksp_monitor -my_order 2
\endcode

To vizualise results first convert the out put file from .h5m format to a vtk one

\code 
mbconvert out.h5m out.vtk
\endcode

then open the .vtk file in paraview

\code 
open out.vtk
\endcode

*/