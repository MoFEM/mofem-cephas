/** \file Gel.hpp
  \brief Implementation of Gel finite element
*/

/* This file is part of MoFEM.
 * MoFEM is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * MoFEM is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with MoFEM. If not, see <http://www.gnu.org/licenses/>. */

#ifndef __GEL_HPP__
#define __GEL_HPP__

#ifndef WITH_ADOL_C
  #error "MoFEM need to be compiled with ADOL-C"
#endif

/** \brief Implementation of Gel constitutive model

Implementation follows constitutive equation from:

VISCOELASTICITY AND POROELASTICITY IN ELASTOMERIC GELS
Acta Mechanica Solida Sinica, Vol. 25, No. 5,
Yuhang Hu Zhigang Suo

Note1: Following implication is tailored for large strain analysis,
however in current version the engineering strain is used, i.e. assuming small deformation.
Moreover calculation of solvent flux and other physical quantities is with
assumption that those values are nonlinear.

Note2: Basic implementation is with linear constitutive equations, however
adding nonlinearities to model should be simple, since all tangent matrices
are calculated using adloc-c.

*/
struct Gel {

  enum TagEvaluate {
    STRESSTOTAL,
    SOLVENTFLUX,
    VOLUMERATE,
    RESIDUALSTRAINHAT
  };

  FieldInterface &mFiled;

  /** \brief Gel material parameters
  */
  struct BlockMaterialData {

    double vAlpha;        ///< Poisson ration spring alpha
    double gAlpha;        ///< Sheer modulus spring alpha
    double vBeta;
    double gBeta;
    double vBetaHat;
    double gBetaHat;
    double pErmeability;
    double vIscosity;
    double oMega;         ///< Volume per solvent molecule

  };
  BlockMaterialData blockMaterialData;

  /** \brief Constitutive model functions

  \image html gel_spring_daspot_model.png "Gel model" width=6cm

  */
  template<typename TYPE>
  struct ConstitutiveEquation {

    BlockMaterialData &dAta;

    ConstitutiveEquation(BlockMaterialData &data):
    dAta(data) {
    }

    // Input

    ublas::matrix<TYPE> F;            ///< Gradient of deformation
    ublas::matrix<TYPE> FDot;         ///< Rate of gradient of deformation
    ublas::matrix<TYPE> strainHat;    ///< Internal variable, strain in dashpot beta
    ublas::matrix<TYPE> strainHatDot; ///< Internal variable, strain in dashpot beta
    TYPE mU;                          ///< Solvent concentration
    ublas::vector<TYPE> gradientMu;   ///< Gradient of solvent concentration

    // Internal use

    ublas::matrix<TYPE> C;              ///< Cauchy deformation
    ublas::matrix<TYPE> gradientU;      ///< Gradient of displacements
    ublas::matrix<TYPE> strainTotal;    ///< Total strain applied at integration point

    ublas::matrix<TYPE> stressAlpha;        ///< Stress generated by spring alpha
    ublas::matrix<TYPE> stressBeta;         ///< Stress generated by spring beta
    ublas::matrix<TYPE> strainHatFlux;    ///< Rate of dashpot (beta) strain
    ublas::matrix<TYPE> stressBetaHat;      ///< Stress as result of volume change due to solvent concentration

    TYPE traceStrainTotal;
    TYPE traceStrainHat;
    TYPE traceStressBeta;
    TYPE traceStrainTotalDot;

    // Output

    ublas::matrix<TYPE> stressTotal;              ///< Total stress
    ublas::vector<TYPE> solventFlux;              ///< Solvent flux
    TYPE volumeDot;                               ///< Volume rate change
    ublas::matrix<TYPE> residualStrainHat;        ///< Residual for calculation epsilon hat

    PetscErrorCode calculateCauchyDefromationTensor() {
      PetscFunctionBegin;
      C.resize(3,3);
      noalias(C) = prod(trans(F),F);
      PetscFunctionReturn(0);
    }

    /** \brief Calculate total strain

    */
    PetscErrorCode calculateStrainTotal() {
      PetscFunctionBegin;
      gradientU.resize(3,3,false);
      for(int ii = 0;ii<3;ii++) {
        gradientU(ii,ii) -= 1;
      }
      noalias(gradientU) = F;
      strainTotal.resize(3,3,false);
      noalias(strainTotal) = gradientU + trans(gradientU);
      strainTotal *= 0.5;
      PetscFunctionReturn(0);
    }

    /** \berief Calculate trace of rate of gradient of deformation
    */
    PetscErrorCode calculateTraceStrainTotalDot() {
      PetscFunctionBegin;
      traceStrainTotalDot = 0;
      for(int ii = 0;ii<3;ii++) {
        traceStrainTotalDot += FDot(ii,ii) - 1.0;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress in spring alpha

    \f[
    \sigma^\alpha_{ij} = 2G^\alpha\left(\varepsilon_{ij} + \frac{v^\alpha}{1-2v^\alpha}\varepsilon_{kk}\delta_{ij}\right)
    \f]

    Note: In general implementation for large strain this function should calculate
    Piola-Kirchhoff Stress I.

    */
    PetscErrorCode calculateStressAlpha() {
      PetscFunctionBegin;
      traceStrainTotal = strainTotal(0,0)+strainTotal(1,1)+strainTotal(2,2);
      stressAlpha.resize(3,3);
      double a = 2.0*dAta.gAlpha;
      noalias(stressAlpha) = a*strainTotal;
      for(int ii=1; ii<3; ii++){
        stressAlpha(ii,ii) += (a*(dAta.vAlpha/(1.0-2.0*dAta.vAlpha)))*traceStrainTotal;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress in spring beta

    \f[
    \sigma^\beta_{ij} = 2G^\beta\left[
    (\varepsilon_{ij}-\hat{\varepsilon}_{ij})
    + \frac{v^\beta}{1-2v^\beta}(\varepsilon_{kk}-\hat{\varepsilon}_{kk})\delta_{ij}
    \right]
    \f]

    */
    PetscErrorCode calculateStressBeta() {
      PetscFunctionBegin;
      traceStrainHat = strainHat(0,0)+strainHat(1,1)+strainHat(2,2);
      traceStrainTotal = strainTotal(0,0)+strainTotal(0,0)+strainTotal(0,0);
      stressBeta.resize(3,3,false);
      double a = 2.0*dAta.gBeta;
      noalias(stressBeta) = a*(strainTotal-strainHat);
      for(int ii = 0;ii<3;ii++) {
        stressBeta(ii,ii) += (a*(dAta.vBeta/(1.0-2.0*dAta.vBeta)))*(traceStrainTotal-traceStrainHat);
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate rate of strain hat

    \f[
    \frac{\partial \hat{\varepsilon}_{ij}}{\partial t} =
    \frac{1}{2\hat{G}^\beta}
    \left(
    \sigma_{ij}^\beta - \frac{\hat{v}^\beta}{1+\hat{v}^\beta}\sigma_{kk}^\beta\delta_{ij}
    \right)
    \f]

    */
    PetscErrorCode calculateStrainHatFlux() {
      PetscFunctionBegin;
      traceStressBeta = stressBeta(0,0)+stressBeta(1,1)+stressBeta(2,2);
      strainHatFlux.resize(3,3,false);
      double a = -(1.0/(2.0*dAta.gBetaHat));
      noalias(strainHatFlux) = a*stressBeta;
      double b = a*(dAta.vBetaHat/(1.0+dAta.vBetaHat));
      for(int ii = 0;ii<3;ii++) {
        strainHatFlux(ii,ii) -= b*traceStressBeta;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress due to concentration of solvent molecules

    \f[
    \hat{\sigma}_{ij}^\beta = \frac{\Delta\mu}{\Omega}\delta_{ij}
    \f]
    note that \f$\Delta\mu = \mu-\mu_0\f$. In current version of code
    value of \f$\Delta\mu\f$ is approximated.

    */
    PetscErrorCode calculateStressBetaHat() {
      PetscFunctionBegin;
      stressBetaHat.resize(3,3,false);
      stressBetaHat.clear();
      for(int ii=0; ii<3; ii++){
        stressBetaHat(ii,ii) = mU/dAta.oMega;
      }
      PetscFunctionReturn(0);
    }

    // Functions calculating output variables

    PetscErrorCode calculateStressTotal() {
      PetscFunctionBegin;
      stressTotal.resize(3,3,false);
      noalias(stressTotal) = stressAlpha;
      noalias(stressTotal) += stressBeta;
      noalias(stressTotal) += stressBetaHat;

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateResidualStrainHat() {
      PetscFunctionBegin;
      residualStrainHat.resize(3,3,false);
      noalias(residualStrainHat) =  strainHatDot + strainHatFlux;
      PetscFunctionReturn(0);
    }

    /** \brief Calculate flux

    \f[
    J_k =
    -\left(
    \frac{\kappa}{\eta\Omega^2}
    \right)
    \mu_{,i}
    \f]

    */
    PetscErrorCode calculateSolventFlux() {
      PetscFunctionBegin;
      solventFlux=-(dAta.pErmeability/(dAta.vIscosity*dAta.oMega*dAta.oMega))*gradientMu;
      PetscFunctionReturn(0);
    }

    /** \brief Volume change at material point

      FIXME: For simplicity as first approximation set volule change
      as trace of gradient total strain

    */
    PetscErrorCode calculateVolumeDot() {
      PetscFunctionBegin;
      volumeDot = traceStrainTotalDot;
      PetscFunctionReturn(0);
    }


  };

  ConstitutiveEquation<adouble> constitutiveEquation;

  struct CommonData {

    string spatialPositionName;
    string spatialPositionNameDot;
    string strainHatName;
    string strainHatNameDot;
    string muName;

    map<string,vector<VectorDouble > > dataAtGaussPts;
    map<string,vector<MatrixDouble > > gradAtGaussPts;

    vector<ublas::matrix<double> > stressTotal;
    vector<ublas::vector<double> > solventFlux;
    vector<double> volumeDot;
    vector<ublas::matrix<double> > residualStrainHat;

    vector<double*> jacRowPtr;
    vector<ublas::matrix<double> > jacStressTotal;
    vector<ublas::matrix<double> > jacSolventFlux;
    vector<ublas::vector<double> > jacVolumeRate;
    vector<ublas::matrix<double> > jacStrainHat;

    bool recordOn;

    CommonData():
    recordOn(true) {
    }

  };
  CommonData commonData;

  /// \brief  definition of volume element
  struct GelFE: public VolumeElementForcesAndSourcesCore {

    int addToRule; ///< Takes into account HO geometry
    GelFE(FieldInterface &m_field):
    VolumeElementForcesAndSourcesCore(m_field),
    addToRule(1) {
    }

    int getRule(int order) {
      return order-1+addToRule;
    }

  };

  GelFE feRhs,feLhs;

  Gel(FieldInterface &m_field):
  mFiled(m_field),
  constitutiveEquation(blockMaterialData),
  feRhs(m_field),
  feLhs(m_field) {
  }

  struct OpGetDataAtGaussPts: public VolumeElementForcesAndSourcesCore::UserDataOperator {

    CommonData &commonData;
    bool calcVal;
    bool calcGrad;
    EntityType zeroAtType;

    OpGetDataAtGaussPts(
      const string field_name,
      CommonData &common_data,
      bool calc_val,
      bool calc_grad,
      EntityType zero_at_type = MBVERTEX
    ):
    VolumeElementForcesAndSourcesCore::UserDataOperator(
      field_name,UserDataOperator::OPROW
    ),
    commonData(common_data),
    calcVal(calc_val),
    calcGrad(calc_grad),
    zeroAtType(zero_at_type) {
    }

    /** \brief Operator field value
    *
    */
    PetscErrorCode doWork(
      int side,EntityType type,DataForcesAndSurcesCore::EntData &data
    ){
      PetscFunctionBegin;

      try {

        int nb_dofs = data.getFieldData().size();
        if(nb_dofs == 0) {
          PetscFunctionReturn(0);
        }
        int rank = data.getFieldDofs()[0]->get_max_rank();
        int nb_gauss_pts = data.getN().size1();

        // Initialize
        if(calcVal) {
          commonData.dataAtGaussPts[rowFieldName].resize(nb_gauss_pts);
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            commonData.dataAtGaussPts[rowFieldName][gg].resize(rank,false);
          }
        }
        if(calcGrad) {
          commonData.gradAtGaussPts[rowFieldName].resize(nb_gauss_pts);
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            commonData.gradAtGaussPts[rowFieldName][gg].resize(rank,3,false);
          }
        }

        // Zero values
        if(type == zeroAtType) {
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            if(calcVal) {
              commonData.dataAtGaussPts[rowFieldName][gg].clear();
            }
            if(calcGrad) {
              commonData.gradAtGaussPts[rowFieldName][gg].clear();
            }
          }
        }

        ublas::vector<double> &values = data.getFieldData();

        // Calculate values at integration points
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          VectorDouble N = data.getN(gg,nb_dofs/rank);
          MatrixDouble diffN = data.getDiffN(gg,nb_dofs/rank);
          for(int dd = 0;dd<nb_dofs/rank;dd++) {
            for(int rr1 = 0;rr1<rank;rr1++) {
              if(calcVal) {
                commonData.dataAtGaussPts[rowFieldName][gg][rr1] += N[dd]*values[rank*dd+rr1];
              }
              if(calcGrad) {
                for(int rr2 = 0;rr2<3;rr2++) {
                  commonData.gradAtGaussPts[rowFieldName][gg](rr1,rr2) += diffN(dd,rr2)*values[rank*dd+rr1];
                }
              }
            }
          }
        }

      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

  };

  struct OpJacobian: public VolumeElementForcesAndSourcesCore::UserDataOperator {

    vector<int> tagS;
    ConstitutiveEquation<adouble> &cE;
    CommonData &commonData;

    bool calculateResidualBool;
    bool calculateJacobianBool;
    bool &recordOn;

    OpJacobian(
      const string field_name,
      vector<int> tags,
      ConstitutiveEquation<adouble> &ce,
      CommonData &common_data,
      bool calculate_residual,
      bool calculate_jacobian
    ):
    VolumeElementForcesAndSourcesCore::UserDataOperator(
      field_name,UserDataOperator::OPROW
    ),
    tagS(tags),
    cE(ce),
    commonData(common_data),
    calculateResidualBool(calculate_residual),
    calculateJacobianBool(calculate_jacobian),
    recordOn(common_data.recordOn) {
    }

    int nbGaussPts;
    map<int,int> nbActiveVariables,nbActiveResults;
    ublas::vector<double> activeVariables;
    ublas::matrix<double> stressTotal;
    ublas::matrix<double> residualStrainHat;

    PetscErrorCode recordStressTotal() {
      PetscFunctionBegin;

      try {
        if(tagS[STRESSTOTAL]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        cE.F.resize(3,3,false);
        cE.strainHat.resize(3,3,false);
        ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
        ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[0];
        ublas::vector<double> mu = (commonData.dataAtGaussPts[commonData.muName])[0];
        trace_on(tagS[STRESSTOTAL]);
        {
          // Activate gradient of defamation
          nbActiveVariables[tagS[STRESSTOTAL]] = 0;
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              cE.F(dd1,dd2) <<= F(dd1,dd2);
              nbActiveVariables[tagS[STRESSTOTAL]]++;
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          cE.strainHat(0,0) <<= strain_hat[0];
          cE.strainHat(1,1) <<= strain_hat[1];
          cE.strainHat(2,2) <<= strain_hat[2];
          cE.strainHat(0,1) <<= strain_hat[3];
          cE.strainHat(1,2) <<= strain_hat[4];
          cE.strainHat(0,2) <<= strain_hat[5];
          nbActiveVariables[tagS[0]] += 6;
          cE.strainHat(1,0) = cE.strainHat(0,1);
          cE.strainHat(2,1) = cE.strainHat(1,2);
          cE.strainHat(2,0) = cE.strainHat(0,2);
          cE.mU <<= mu[0];
          nbActiveVariables[tagS[STRESSTOTAL]]++;
          // Do calculations
          ierr = cE.calculateStrainTotal(); CHKERRQ(ierr);
          ierr = cE.calculateStressAlpha(); CHKERRQ(ierr);
          ierr = cE.calculateStressBeta(); CHKERRQ(ierr);
          ierr = cE.calculateStressBetaHat(); CHKERRQ(ierr);
          // Finally calculate result
          ierr = cE.calculateStressTotal(); CHKERRQ(ierr);
          // Results
          nbActiveResults[tagS[STRESSTOTAL]] = 0;
          commonData.stressTotal.resize(nbGaussPts);
          commonData.stressTotal[0].resize(3,3,false);
          for(int d1 = 0;d1<3;d1++) {
            for(int d2 = 0;d2<3;d2++) {
              cE.stressTotal(d1,d2) >>= (commonData.stressTotal[0])(d1,d2);
              nbActiveResults[tagS[STRESSTOTAL]]++;
            }
          }
        }
        trace_off();
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }

    PetscErrorCode recordSolventFlux() {
      PetscFunctionBegin;

      try {
        if(tagS[SOLVENTFLUX]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        cE.gradientMu.resize(3,false);
        ublas::matrix<double> &gradient_mu = (commonData.gradAtGaussPts[commonData.muName])[0];
        trace_on(tagS[SOLVENTFLUX]);
        {
          // Activate rate of gradient of defamation
          nbActiveVariables[tagS[SOLVENTFLUX]] = 0;
          for(int ii = 0;ii<3;ii++) {
            cE.gradientMu[ii] <<= gradient_mu(0,ii);
            nbActiveVariables[tagS[SOLVENTFLUX]]++;
          }
          ierr = cE.calculateSolventFlux(); CHKERRQ(ierr);
          nbActiveResults[tagS[SOLVENTFLUX]] = 0;
          commonData.solventFlux.resize(nbGaussPts);
          commonData.solventFlux[0].resize(3,false);
          for(int d1 = 0;d1<3;d1++) {
            cE.solventFlux[d1] >>= commonData.solventFlux[0][d1];
            nbActiveResults[tagS[SOLVENTFLUX]]++;
          }
        }
        trace_off();
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode recordVolumeDot() {
      PetscFunctionBegin;

      if(tagS[VOLUMERATE]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
      ublas::matrix<double> &F_dot = (commonData.gradAtGaussPts[commonData.spatialPositionNameDot])[0];

      trace_on(tagS[VOLUMERATE]);
      {
        // Activate rate of gradient of defamation
        nbActiveVariables[tagS[VOLUMERATE]] = 0;
        cE.F.resize(3,3,false);
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE.F(dd1,dd2) <<= F(dd1,dd2);
            nbActiveVariables[tagS[VOLUMERATE]]++;
          }
        }
        cE.FDot.resize(3,3,false);
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE.FDot(dd1,dd2) <<= F_dot(dd1,dd2);
            nbActiveVariables[tagS[VOLUMERATE]]++;
          }
        }
        ierr = cE.calculateTraceStrainTotalDot(); CHKERRQ(ierr);
        ierr = cE.calculateVolumeDot(); CHKERRQ(ierr);
        nbActiveResults[tagS[VOLUMERATE]] = 0;
        commonData.volumeDot.resize(nbGaussPts);
        cE.volumeDot >>= commonData.volumeDot[0];
        nbActiveResults[tagS[VOLUMERATE]]++;
      }
      trace_off();

      PetscFunctionReturn(0);
    }

    PetscErrorCode recordResidualStrainHat() {
      PetscFunctionBegin;

      if(tagS[RESIDUALSTRAINHAT]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      cE.F.resize(3,3,false);
      cE.strainHat.resize(3,3,false);
      cE.strainHatDot.resize(3,3,false);
      ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
      ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[0];
      ublas::vector<double> &strain_hat_dot = (commonData.dataAtGaussPts[commonData.strainHatNameDot])[0];
      trace_on(tagS[RESIDUALSTRAINHAT]);
      {
        // Activate gradient of defamation
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] = 0;
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE.F(dd1,dd2) <<= F(dd1,dd2);
            nbActiveVariables[tagS[RESIDUALSTRAINHAT]]++;
          }
        }
        // Using vector notation to store hatStrain
        // xx,yy,zz,2xy,2yz,2zy
        cE.strainHat(0,0) <<= strain_hat[0];
        cE.strainHat(1,1) <<= strain_hat[1];
        cE.strainHat(2,2) <<= strain_hat[2];
        cE.strainHat(0,1) <<= strain_hat[3];
        cE.strainHat(1,2) <<= strain_hat[4];
        cE.strainHat(0,2) <<= strain_hat[5];
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] += 6;
        cE.strainHat(1,0) = cE.strainHat(0,1);
        cE.strainHat(2,1) = cE.strainHat(1,2);
        cE.strainHat(2,0) = cE.strainHat(0,2);
        // Activate strain hat dot
        cE.strainHatDot(0,0) <<= strain_hat_dot[0];
        cE.strainHatDot(1,1) <<= strain_hat_dot[1];
        cE.strainHatDot(2,2) <<= strain_hat_dot[2];
        cE.strainHatDot(0,1) <<= strain_hat_dot[3];
        cE.strainHatDot(1,2) <<= strain_hat_dot[4];
        cE.strainHatDot(0,2) <<= strain_hat_dot[5];
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] += 6;
        cE.strainHatDot(1,0) = cE.strainHatDot(0,1);
        cE.strainHatDot(2,1) = cE.strainHatDot(1,2);
        cE.strainHatDot(2,0) = cE.strainHatDot(0,2);
        ierr = cE.calculateStressBeta(); CHKERRQ(ierr);
        ierr = cE.calculateStrainHatFlux(); CHKERRQ(ierr);
        ierr = cE.calculateResidualStrainHat(); CHKERRQ(ierr);
        nbActiveResults[tagS[RESIDUALSTRAINHAT]] = 0;
        commonData.residualStrainHat.resize(nbGaussPts);
        commonData.residualStrainHat[0].resize(3,3,false);
        for(int d1 = 0;d1<3;d1++) {
          for(int d2 = 0;d2<3;d2++) {
            cE.residualStrainHat(d1,d2) >>= commonData.residualStrainHat[0](d1,d2);
            nbActiveResults[tagS[RESIDUALSTRAINHAT]]++;
          }
        }
      }
      trace_off();

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateFunction(TagEvaluate te,double *ptr) {
      PetscFunctionBegin;

      int r;
      //play recorder for values
      r = ::function(
        tagS[te],
        nbActiveResults[tagS[te]],
        nbActiveVariables[tagS[te]],
        &activeVariables[0],
        ptr
      );
      if(r<3) { // function is locally analytic
        SETERRQ1(PETSC_COMM_SELF,MOFEM_OPERATION_UNSUCCESSFUL,"ADOL-C function evaluation with error r = %d",r);
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateJacobian(TagEvaluate te) {
      PetscFunctionBegin;

      int r;
      r = jacobian(
        tagS[te],
        nbActiveResults[tagS[te]],
        nbActiveVariables[tagS[te]],
        &activeVariables[0],
        &(commonData.jacRowPtr[0])
      );
      if(r<3) {
        SETERRQ(PETSC_COMM_SELF,MOFEM_OPERATION_UNSUCCESSFUL,"ADOL-C function evaluation with error");
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsStressTotal() {
      PetscFunctionBegin;

      try {

        if(tagS[STRESSTOTAL]<0) {
          PetscFunctionReturn(0);
        }


        PetscErrorCode ierr;

        activeVariables.resize(nbActiveVariables[tagS[STRESSTOTAL]],false);

        for(int gg = 0;gg<nbGaussPts;gg++) {

          ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
          ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[gg];
          double mu = (commonData.dataAtGaussPts[commonData.muName])[gg][0];

          int nb_active_variables = 0;
          // Activate gradient of defamation
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              activeVariables[nb_active_variables++] = F(dd1,dd2);
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat[ii];
          }
          activeVariables[nb_active_variables++] = mu;

          if(nb_active_variables!=nbActiveVariables[tagS[STRESSTOTAL]]) {
            SETERRQ(
              PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
            );
          }

          if(calculateResidualBool) {
            commonData.stressTotal[gg].resize(3,3,false);
            ierr = calculateFunction(STRESSTOTAL,&commonData.stressTotal[gg](0,0)); CHKERRQ(ierr);
          }

          if(calculateJacobianBool) {

            if(gg == 0) {
              commonData.jacStressTotal.resize(nbGaussPts);
              commonData.jacRowPtr.resize(nbActiveResults[tagS[STRESSTOTAL]]);
            }
            commonData.jacStressTotal[gg].resize(
              nbActiveResults[tagS[STRESSTOTAL]],
              nbActiveVariables[tagS[STRESSTOTAL]]
            );
            for(int dd = 0;dd<nbActiveResults[tagS[STRESSTOTAL]];dd++) {
              commonData.jacRowPtr[dd] = &commonData.jacStressTotal[gg](dd,0);
            }

            ierr = calculateJacobian(STRESSTOTAL); CHKERRQ(ierr);

          }

        }

      } catch (const std::exception& ex) {
          ostringstream ss;
          ss << "throw in method: " << ex.what() << endl;
          SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
        }


      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsSolventFlux() {
      PetscFunctionBegin;

      if(tagS[SOLVENTFLUX]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      activeVariables.resize(nbActiveResults[tagS[SOLVENTFLUX]]);

      for(int gg = 0;gg<nbGaussPts;gg++) {

        ublas::matrix<double> &gradient_mu = (commonData.gradAtGaussPts[commonData.muName])[gg];

        int nb_active_variables = 0;
        // Activate rate of gradient of defamation
        for(int ii = 0;ii<3;ii++) {
          activeVariables[nb_active_variables++] = gradient_mu(0,ii);
        }

        if(nb_active_variables!=nbActiveVariables[tagS[SOLVENTFLUX]]) {
          SETERRQ(
            PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
          );
        }

        if(calculateResidualBool) {
          commonData.solventFlux[gg].resize(3,false);
          ierr = calculateFunction(
            SOLVENTFLUX,
            &(commonData.solventFlux[gg][0])
          ); CHKERRQ(ierr);
        }

        if(calculateJacobianBool) {
          if(gg == 0) {
            commonData.jacSolventFlux.resize(nbGaussPts);
            commonData.jacRowPtr.resize(nbActiveResults[tagS[SOLVENTFLUX]]);
          }
          commonData.jacSolventFlux[gg].resize(
            nbActiveResults[tagS[SOLVENTFLUX]],
            nbActiveVariables[tagS[SOLVENTFLUX]],
            false
          );
          for(int dd = 0;dd<nbActiveResults[tagS[SOLVENTFLUX]];dd++) {
            commonData.jacRowPtr[dd] = &(commonData.jacSolventFlux[gg](0,0));
          }
          ierr = calculateJacobian(SOLVENTFLUX); CHKERRQ(ierr);

        }
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsVolumeDot() {
      PetscFunctionBegin;

      if(tagS[VOLUMERATE]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      activeVariables.resize(nbActiveVariables[tagS[VOLUMERATE]],false);

      for(int gg = 0;gg<nbGaussPts;gg++) {
        ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
        ublas::matrix<double> &F_dot = (commonData.gradAtGaussPts[commonData.spatialPositionNameDot])[gg];
        int nb_active_variables = 0;
        // Activate gradient of defamation
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            activeVariables[nb_active_variables++] = F(dd1,dd2);
          }
        }
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            activeVariables[nb_active_variables++] = F_dot(dd1,dd2);
          }
        }
        if(nb_active_variables!=nbActiveVariables[tagS[VOLUMERATE]]) {
          SETERRQ(
            PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
          );
        }
        if(calculateResidualBool) {
          ierr = calculateFunction(VOLUMERATE,&commonData.stressTotal[gg](0,0)); CHKERRQ(ierr);
        }
        if(calculateJacobianBool) {
          if(gg == 0) {
            commonData.jacVolumeRate.resize(nbGaussPts);
            commonData.jacRowPtr.resize(nbActiveResults[tagS[VOLUMERATE]]);
          }
          commonData.jacVolumeRate[gg].resize(nbActiveVariables[tagS[VOLUMERATE]]);
          commonData.jacRowPtr[0] = &commonData.jacVolumeRate[gg][0];
          ierr = calculateJacobian(VOLUMERATE); CHKERRQ(ierr);
        }
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtrsResidualStrainHat() {
      PetscFunctionBegin;

      try {
        if(tagS[RESIDUALSTRAINHAT]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        activeVariables.resize(nbActiveVariables[tagS[RESIDUALSTRAINHAT]]);
        for(int gg = 0;gg<nbGaussPts;gg++) {
          ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
          ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[gg];
          ublas::vector<double> &strain_hat_dot = (commonData.dataAtGaussPts[commonData.strainHatNameDot])[gg];
          int nb_active_variables = 0;
          // Activate gradient of defamation
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              activeVariables[nb_active_variables++] = F(dd1,dd2);
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat[ii];
          }
          // Using vector notation to store hatStrainDot
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat_dot[ii];
          }
          if(nb_active_variables!=nbActiveVariables[tagS[RESIDUALSTRAINHAT]]) {
            SETERRQ(
              PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
            );
          }
          if(calculateResidualBool) {
            commonData.residualStrainHat[gg].resize(3,3,false);
            ierr = calculateFunction(
              RESIDUALSTRAINHAT,&commonData.residualStrainHat[gg](0,0)
            ); CHKERRQ(ierr);
          }
          if(calculateJacobianBool) {
            if(gg == 0) {
              commonData.jacStrainHat.resize(nbGaussPts);
              commonData.jacRowPtr.resize(nbActiveResults[tagS[RESIDUALSTRAINHAT]]);
            }
            commonData.jacStrainHat[gg].resize(
              nbActiveResults[tagS[RESIDUALSTRAINHAT]],
              nbActiveVariables[tagS[RESIDUALSTRAINHAT]],
              false
            );
            for(int dd = 0;dd<nbActiveResults[tagS[RESIDUALSTRAINHAT]];dd++) {
              commonData.jacRowPtr[dd] = &commonData.jacStrainHat[gg](dd,0);
            }
            ierr = calculateJacobian(RESIDUALSTRAINHAT); CHKERRQ(ierr);
          }
        }


      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      PetscErrorCode ierr;

      if(row_type != MBVERTEX) PetscFunctionReturn(0);
      nbGaussPts = row_data.getN().size1();

      try {

        if(recordOn) {
          ierr = recordStressTotal(); CHKERRQ(ierr);
          ierr = recordSolventFlux(); CHKERRQ(ierr);
          ierr = recordVolumeDot(); CHKERRQ(ierr);
          ierr = recordResidualStrainHat(); CHKERRQ(ierr);
        }

        ierr = calculateAtIntPtsStressTotal(); CHKERRQ(ierr);
        ierr = calculateAtIntPtsSolventFlux(); CHKERRQ(ierr);
        ierr = calculateAtIntPtsVolumeDot(); CHKERRQ(ierr);
        ierr = calculateAtIntPtrsResidualStrainHat(); CHKERRQ(ierr);

      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

  };

  struct AssembleVector: VolumeElementForcesAndSourcesCore::UserDataOperator {
    AssembleVector(string field_name):
    VolumeElementForcesAndSourcesCore::UserDataOperator(field_name,UserDataOperator::OPROW) {
    }
    PetscErrorCode ierr;
    ublas::vector<double> nF;
    PetscErrorCode aSemble(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        int *indices_ptr = &row_data.getIndices()[0];
        ierr = VecSetValues(
          getFEMethod()->snes_f,nb_dofs,indices_ptr,&nF[0],ADD_VALUES
        ); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble internal force vector

  \f[
  (\mathbf{f}_x)_i =
  \int_V
  \frac{\partial N_i}{\partial X_j} \sigma_{ij}
  \textrm{d}V
  \f]

  */
  struct OpRhsAssembleStrainTotal: public AssembleVector {
    CommonData &commonData;
    OpRhsAssembleStrainTotal(CommonData &common_data):
    AssembleVector(common_data.spatialPositionName),
    commonData(common_data) {
    }

    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_dofs/3);
          const ublas::matrix<double>& stress = commonData.stressTotal[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs/3;dd++) {
            for(int rr = 0;rr<3;rr++) {
              for(int nn = 0;nn<3;nn++) {
                nF[3*dd+rr] += val*diffN(dd,nn)*stress(rr,nn);
              }
            }
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \berief Calculate internal forces for solvent flux

  \f[
  (\mathbf{f}_{\mu})_j =
  \int_V
  \frac{\partial N_j}{\partial X_k} J_k
  \textrm{d}V
  \f]

  */
  struct OpRhsAssembleSolventFlux: public AssembleVector {
    CommonData &commonData;
    OpRhsAssembleSolventFlux(CommonData &common_data):
    AssembleVector(common_data.muName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_dofs);
          const ublas::vector<double>& flux = commonData.solventFlux[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs;dd++) {
            for(int nn = 0;nn<3;nn++) {
              nF[dd] += val*diffN(dd,nn)*flux(nn);
            }
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Calculating right hand side

  \f[
  (\mathbf{f}_\mu)_j =
  \int_V
  N_j \frac{\partial V}{\partial t}
  \textrm{d}V
  \f]

  */
  struct OpRhsVolumeDot: public AssembleVector {
    CommonData &commonData;
    OpRhsVolumeDot(CommonData &common_data):
    AssembleVector(common_data.muName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const VectorAdaptor &N = row_data.getN(gg,nb_dofs);
          double volume_dot = commonData.volumeDot[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          nF += val*N*volume_dot;
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  struct OpRhsStrainHat: public AssembleVector {
    CommonData &commonData;
    OpRhsStrainHat(CommonData &common_data):
    AssembleVector(common_data.strainHatName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const VectorAdaptor &N = row_data.getN(gg,nb_dofs/6);
          ublas::matrix<double> strain_hat = commonData.residualStrainHat[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs/6;dd++) {
            nF[dd*6+0] += val*N[dd]*strain_hat(0,0);
            nF[dd*6+1] += val*N[dd]*strain_hat(1,1);
            nF[dd*6+2] += val*N[dd]*strain_hat(2,2);
            nF[dd*6+3] += val*N[dd]*strain_hat(0,1);
            nF[dd*6+4] += val*N[dd]*strain_hat(1,2);
            nF[dd*6+5] += val*N[dd]*strain_hat(0,2);
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

};

#endif //__GEL_HPP__
