/** \file Gels.hpp
  \brief Implementation of Gel finite element
  \ingroup gel
*/

/* This file is part of MoFEM.
 * MoFEM is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * MoFEM is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with MoFEM. If not, see <http://www.gnu.org/licenses/>. */

#ifndef __GEL_HPP__
#define __GEL_HPP__

#ifndef WITH_ADOL_C
  #error "MoFEM need to be compiled with ADOL-C"
#endif

/** \brief Implementation of Gel constitutive model
\ingroup gel

Implementation follows constitutive equation from:

VISCOELASTICITY AND POROELASTICITY IN ELASTOMERIC GELS
Acta Mechanica Solida Sinica, Vol. 25, No. 5,
Yuhang Hu Zhigang Suo

Note1: Following implementation is tailored for large strain analysis,
however in current version the engineering strain is used, i.e. assuming small deformation.
Moreover calculation of solvent flux and other physical quantities is with
assumption that those values are nonlinear.

Note2: Basic implementation is with linear constitutive equations, however
adding nonlinearities to model should be simple, since all tangent matrices
are calculated using adloc-c.

System of equations of equations in the form is assembled:
\f[
\left[
\begin{array}{ccc}
\mathbf{K}_{xx} & \mathbf{K}_{x\mu} & \mathbf{K}_{x\hat{\varepsilon}} \\
\mathbf{K}_{\mu x} & \mathbf{K}_{\mu \mu} & \mathbf{K}_{\mu \hat{\varepsilon}} \\
\mathbf{K}_{\hat{\varepsilon} x} & \mathbf{K}_{\hat{\varepsilon} \mu} & \mathbf{K}_{\hat{\varepsilon} \hat{\varepsilon}}
\end{array}
\right]
\left[
\begin{array}{c}
\mathbf{q}_{x}\\
\mathbf{q}_{\mu}\\
\mathbf{q}_{\hat{\varepsilon}}
\end{array}
\right]
=
\left[
\begin{array}{l}
\mathbf{f}^\textrm{internal}_{x}\\
\mathbf{f}^V_{\mu}+\mathbf{f}^J_{\mu}\\
\mathbf{r}_{\hat{\varepsilon}}
\end{array}
\right]
\f]

*/
struct Gel {

  enum TagEvaluate {
    STRESSTOTAL,
    SOLVENTFLUX,
    VOLUMERATE,
    RESIDUALSTRAINHAT
  };

  FieldInterface &mFiled;

  /** \brief Gel material parameters
  \ingroup gel
  */
  struct BlockMaterialData {

    double vAlpha;        ///< Poisson ration spring alpha
    double gAlpha;        ///< Sheer modulus spring alpha
    double vBeta;
    double gBeta;
    double vBetaHat;
    double gBetaHat;
    double pErmeability;
    double vIscosity;
    double oMega;         ///< Volume per solvent molecule

  };
  BlockMaterialData blockMaterialData;

  /** \brief Constitutive model functions
  \ingroup gel

  \image html gel_spring_daspot_model.png "Gel model" width=6cm

  */
  template<typename TYPE>
  struct ConstitutiveEquation {

    BlockMaterialData &dAta;

    ConstitutiveEquation(BlockMaterialData &data):
    dAta(data) {
    }

    // Input

    ublas::matrix<TYPE> F;            ///< Gradient of deformation
    ublas::matrix<TYPE> FDot;         ///< Rate of gradient of deformation
    ublas::matrix<TYPE> strainHat;    ///< Internal variable, strain in dashpot beta
    ublas::matrix<TYPE> strainHatDot; ///< Internal variable, strain in dashpot beta
    TYPE mU;                          ///< Solvent concentration
    ublas::vector<TYPE> gradientMu;   ///< Gradient of solvent concentration

    // Internal use

    ublas::matrix<TYPE> C;              ///< Cauchy deformation
    ublas::matrix<TYPE> gradientU;      ///< Gradient of displacements
    ublas::matrix<TYPE> strainTotal;    ///< Total strain applied at integration point

    ublas::matrix<TYPE> stressAlpha;        ///< Stress generated by spring alpha
    ublas::matrix<TYPE> stressBeta;         ///< Stress generated by spring beta
    ublas::matrix<TYPE> strainHatFlux;    ///< Rate of dashpot (beta) strain
    ublas::matrix<TYPE> stressBetaHat;      ///< Stress as result of volume change due to solvent concentration

    TYPE traceStrainTotal;
    TYPE traceStrainHat;
    TYPE traceStressBeta;
    TYPE traceStrainTotalDot;

    // Output

    ublas::matrix<TYPE> stressTotal;              ///< Total stress
    ublas::vector<TYPE> solventFlux;              ///< Solvent flux
    TYPE volumeDot;                               ///< Volume rate change
    ublas::matrix<TYPE> residualStrainHat;        ///< Residual for calculation epsilon hat

    virtual PetscErrorCode calculateCauchyDefromationTensor() {
      PetscFunctionBegin;
      C.resize(3,3);
      noalias(C) = prod(trans(F),F);
      PetscFunctionReturn(0);
    }

    /** \brief Calculate total strain

    */
    virtual PetscErrorCode calculateStrainTotal() {
      PetscFunctionBegin;
      gradientU.resize(3,3,false);
      for(int ii = 0;ii<3;ii++) {
        gradientU(ii,ii) -= 1;
      }
      noalias(gradientU) = F;
      strainTotal.resize(3,3,false);
      noalias(strainTotal) = gradientU + trans(gradientU);
      strainTotal *= 0.5;
      PetscFunctionReturn(0);
    }

    /** \berief Calculate trace of rate of gradient of deformation
    */
    virtual PetscErrorCode calculateTraceStrainTotalDot() {
      PetscFunctionBegin;
      traceStrainTotalDot = 0;
      for(int ii = 0;ii<3;ii++) {
        traceStrainTotalDot += FDot(ii,ii) - 1.0;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress in spring alpha

    \f[
    \sigma^\alpha_{ij} = 2G^\alpha\left(\varepsilon_{ij} + \frac{v^\alpha}{1-2v^\alpha}\varepsilon_{kk}\delta_{ij}\right)
    \f]

    Note: In general implementation for large strain this function should calculate
    Piola-Kirchhoff Stress I.

    */
    virtual PetscErrorCode calculateStressAlpha() {
      PetscFunctionBegin;
      traceStrainTotal = strainTotal(0,0)+strainTotal(1,1)+strainTotal(2,2);
      stressAlpha.resize(3,3);
      double a = 2.0*dAta.gAlpha;
      noalias(stressAlpha) = a*strainTotal;
      for(int ii=1; ii<3; ii++){
        stressAlpha(ii,ii) += (a*(dAta.vAlpha/(1.0-2.0*dAta.vAlpha)))*traceStrainTotal;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress in spring beta

    \f[
    \sigma^\beta_{ij} = 2G^\beta\left[
    (\varepsilon_{ij}-\hat{\varepsilon}_{ij})
    + \frac{v^\beta}{1-2v^\beta}(\varepsilon_{kk}-\hat{\varepsilon}_{kk})\delta_{ij}
    \right]
    \f]

    */
    virtual PetscErrorCode calculateStressBeta() {
      PetscFunctionBegin;
      traceStrainHat = strainHat(0,0)+strainHat(1,1)+strainHat(2,2);
      traceStrainTotal = strainTotal(0,0)+strainTotal(1,1)+strainTotal(2,2);
      stressBeta.resize(3,3,false);
      double a = 2.0*dAta.gBeta;
      noalias(stressBeta) = a*(strainTotal-strainHat);
      for(int ii = 0;ii<3;ii++) {
        stressBeta(ii,ii) += (a*(dAta.vBeta/(1.0-2.0*dAta.vBeta)))*(traceStrainTotal-traceStrainHat);
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate rate of strain hat

    \f[
    \frac{\partial \hat{\varepsilon}_{ij}}{\partial t} =
    \frac{1}{2\hat{G}^\beta}
    \left(
    \sigma_{ij}^\beta - \frac{\hat{v}^\beta}{1+\hat{v}^\beta}\sigma_{kk}^\beta\delta_{ij}
    \right)
    \f]

    */
    virtual PetscErrorCode calculateStrainHatFlux() {
      PetscFunctionBegin;
      traceStressBeta = stressBeta(0,0)+stressBeta(1,1)+stressBeta(2,2);
      strainHatFlux.resize(3,3,false);
      double a = -(1.0/(2.0*dAta.gBetaHat));
      noalias(strainHatFlux) = a*stressBeta;
      double b = a*(dAta.vBetaHat/(1.0+dAta.vBetaHat));
      for(int ii = 0;ii<3;ii++) {
        strainHatFlux(ii,ii) -= b*traceStressBeta;
      }
      PetscFunctionReturn(0);
    }

    /** \brief Calculate stress due to concentration of solvent molecules

    \f[
    \hat{\sigma}_{ij}^\beta = \frac{\Delta\mu}{\Omega}\delta_{ij}
    \f]
    note that \f$\Delta\mu = \mu-\mu_0\f$. In current version of code
    value of \f$\Delta\mu\f$ is approximated.

    */
    virtual PetscErrorCode calculateStressBetaHat() {
      PetscFunctionBegin;
      stressBetaHat.resize(3,3,false);
      stressBetaHat.clear();
      for(int ii=0; ii<3; ii++){
        stressBetaHat(ii,ii) = mU/dAta.oMega;
      }
      PetscFunctionReturn(0);
    }

    // Functions calculating output variables

    virtual PetscErrorCode calculateStressTotal() {
      PetscFunctionBegin;
      stressTotal.resize(3,3,false);
      noalias(stressTotal) = stressAlpha;
      noalias(stressTotal) += stressBeta;
      noalias(stressTotal) += stressBetaHat;

      PetscFunctionReturn(0);
    }

    virtual PetscErrorCode calculateResidualStrainHat() {
      PetscFunctionBegin;
      residualStrainHat.resize(3,3,false);
      noalias(residualStrainHat) =  strainHatDot + strainHatFlux;
      PetscFunctionReturn(0);
    }

    /** \brief Calculate flux

    \f[
    J_k =
    -\left(
    \frac{\kappa}{\eta\Omega^2}
    \right)
    \mu_{,i}
    \f]

    */
    virtual PetscErrorCode calculateSolventFlux() {
      PetscFunctionBegin;
      solventFlux=-(dAta.pErmeability/(dAta.vIscosity*dAta.oMega*dAta.oMega))*gradientMu;
      PetscFunctionReturn(0);
    }

    /** \brief Volume change at material point

      FIXME: For simplicity as first approximation set volume change
      as trace of gradient total strain

    */
    virtual PetscErrorCode calculateVolumeDot() {
      PetscFunctionBegin;
      volumeDot = traceStrainTotalDot;
      PetscFunctionReturn(0);
    }

  };

  boost::shared_ptr<Gel::ConstitutiveEquation<adouble> > constitutiveEquationPtr;

  /** \brief Common data for gel model
  \ingroup gel
  */
  struct CommonData {

    string spatialPositionName;
    string spatialPositionNameDot;
    string strainHatName;
    string strainHatNameDot;
    string muName;
    string muNameDot;

    map<string,vector<VectorDouble > > dataAtGaussPts;
    map<string,vector<MatrixDouble > > gradAtGaussPts;

    vector<ublas::matrix<double> > stressTotal;
    vector<ublas::vector<double> > solventFlux;
    vector<double> volumeDot;
    vector<ublas::matrix<double> > residualStrainHat;

    vector<double*> jacRowPtr;
    vector<ublas::matrix<double> > jacStressTotal;
    vector<ublas::matrix<double> > jacSolventFlux;
    vector<ublas::vector<double> > jacVolumeRate;
    vector<ublas::matrix<double> > jacStrainHat;

    bool recordOn;

    CommonData():
    recordOn(true) {
    }

  };
  CommonData commonData;

  /// \brief  definition of volume element
  struct GelFE: public VolumeElementForcesAndSourcesCore {

    CommonData &commonData;
    int addToRule; ///< Takes into account HO geometry

    GelFE(FieldInterface &m_field,CommonData &common_data):
    VolumeElementForcesAndSourcesCore(m_field),
    commonData(common_data),
    addToRule(1) {
    }

    int getRule(int order) {
      return order-1+addToRule;
    }

    PetscErrorCode preProcess() {
      PetscFunctionBegin;
      ierr = VolumeElementForcesAndSourcesCore::preProcess(); CHKERRQ(ierr);

      if(ts_ctx == CTX_TSSETIFUNCTION) {

        ierr = mField.set_other_local_ghost_vector(
          problemPtr,
          commonData.spatialPositionName,
          commonData.spatialPositionNameDot,
          ROW,
          ts_u_t,
          INSERT_VALUES,
          SCATTER_REVERSE
        ); CHKERRQ(ierr);

        ierr = mField.set_other_local_ghost_vector(
          problemPtr,
          commonData.strainHatName,
          commonData.strainHatNameDot,
          ROW,
          ts_u_t,
          INSERT_VALUES,
          SCATTER_REVERSE
        ); CHKERRQ(ierr);

      }

      PetscFunctionReturn(0);
    }

  };

  GelFE feRhs,feLhs;


  Gel(FieldInterface &m_field):
  mFiled(m_field),
  feRhs(m_field,commonData),
  feLhs(m_field,commonData) {
  }

  struct OpGetDataAtGaussPts: public VolumeElementForcesAndSourcesCore::UserDataOperator {

    CommonData &commonData;
    bool calcVal;
    bool calcGrad;
    EntityType zeroAtType;

    OpGetDataAtGaussPts(
      const string field_name,
      CommonData &common_data,
      bool calc_val,
      bool calc_grad,
      EntityType zero_at_type = MBVERTEX
    ):
    VolumeElementForcesAndSourcesCore::UserDataOperator(
      field_name,UserDataOperator::OPROW
    ),
    commonData(common_data),
    calcVal(calc_val),
    calcGrad(calc_grad),
    zeroAtType(zero_at_type) {
    }

    /** \brief Operator field value
    *
    */
    PetscErrorCode doWork(
      int side,EntityType type,DataForcesAndSurcesCore::EntData &data
    ){
      PetscFunctionBegin;

      try {

        int nb_dofs = data.getFieldData().size();
        if(nb_dofs == 0) {
          PetscFunctionReturn(0);
        }
        int rank = data.getFieldDofs()[0]->get_max_rank();
        int nb_gauss_pts = data.getN().size1();

        // Initialize
        if(calcVal) {
          commonData.dataAtGaussPts[rowFieldName].resize(nb_gauss_pts);
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            commonData.dataAtGaussPts[rowFieldName][gg].resize(rank,false);
          }
        }
        if(calcGrad) {
          commonData.gradAtGaussPts[rowFieldName].resize(nb_gauss_pts);
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            commonData.gradAtGaussPts[rowFieldName][gg].resize(rank,3,false);
          }
        }

        // Zero values
        if(type == zeroAtType) {
          for(int gg = 0;gg<nb_gauss_pts;gg++) {
            if(calcVal) {
              commonData.dataAtGaussPts[rowFieldName][gg].clear();
            }
            if(calcGrad) {
              commonData.gradAtGaussPts[rowFieldName][gg].clear();
            }
          }
        }

        ublas::vector<double> &values = data.getFieldData();

        // Calculate values at integration points
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          VectorDouble N = data.getN(gg,nb_dofs/rank);
          MatrixDouble diffN = data.getDiffN(gg,nb_dofs/rank);
          for(int dd = 0;dd<nb_dofs/rank;dd++) {
            for(int rr1 = 0;rr1<rank;rr1++) {
              if(calcVal) {
                commonData.dataAtGaussPts[rowFieldName][gg][rr1] += N[dd]*values[rank*dd+rr1];
              }
              if(calcGrad) {
                for(int rr2 = 0;rr2<3;rr2++) {
                  commonData.gradAtGaussPts[rowFieldName][gg](rr1,rr2) += diffN(dd,rr2)*values[rank*dd+rr1];
                }
              }
            }
          }
        }

      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

  };

  struct OpJacobian: public VolumeElementForcesAndSourcesCore::UserDataOperator {

    vector<int> tagS;
    boost::shared_ptr<Gel::ConstitutiveEquation<adouble> > cE;
    CommonData &commonData;

    bool calculateResidualBool;
    bool calculateJacobianBool;
    bool &recordOn;

    OpJacobian(
      const string field_name,
      vector<int> tags,
      boost::shared_ptr<Gel::ConstitutiveEquation<adouble> > ce,
      CommonData &common_data,
      bool calculate_residual,
      bool calculate_jacobian
    ):
    VolumeElementForcesAndSourcesCore::UserDataOperator(
      field_name,UserDataOperator::OPROW
    ),
    tagS(tags),
    cE(ce),
    commonData(common_data),
    calculateResidualBool(calculate_residual),
    calculateJacobianBool(calculate_jacobian),
    recordOn(common_data.recordOn) {
    }

    int nbGaussPts;
    map<int,int> nbActiveVariables,nbActiveResults;
    ublas::vector<double> activeVariables;
    ublas::matrix<double> stressTotal;
    ublas::matrix<double> residualStrainHat;

    PetscErrorCode recordStressTotal() {
      PetscFunctionBegin;

      try {
        if(tagS[STRESSTOTAL]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        cE->F.resize(3,3,false);
        cE->strainHat.resize(3,3,false);
        ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
        ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[0];
        ublas::vector<double> mu = (commonData.dataAtGaussPts[commonData.muName])[0];
        trace_on(tagS[STRESSTOTAL]);
        {
          // Activate gradient of defamation
          nbActiveVariables[tagS[STRESSTOTAL]] = 0;
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              cE->F(dd1,dd2) <<= F(dd1,dd2);
              nbActiveVariables[tagS[STRESSTOTAL]]++;
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          cE->strainHat(0,0) <<= strain_hat[0];
          cE->strainHat(1,1) <<= strain_hat[1];
          cE->strainHat(2,2) <<= strain_hat[2];
          cE->strainHat(0,1) <<= strain_hat[3];
          cE->strainHat(1,2) <<= strain_hat[4];
          cE->strainHat(0,2) <<= strain_hat[5];
          nbActiveVariables[tagS[0]] += 6;
          cE->strainHat(1,0) = cE->strainHat(0,1);
          cE->strainHat(2,1) = cE->strainHat(1,2);
          cE->strainHat(2,0) = cE->strainHat(0,2);
          cE->mU <<= mu[0];
          nbActiveVariables[tagS[STRESSTOTAL]]++;
          // Do calculations
          ierr = cE->calculateStrainTotal(); CHKERRQ(ierr);
          ierr = cE->calculateStressAlpha(); CHKERRQ(ierr);
          ierr = cE->calculateStressBeta(); CHKERRQ(ierr);
          ierr = cE->calculateStressBetaHat(); CHKERRQ(ierr);
          // Finally calculate result
          ierr = cE->calculateStressTotal(); CHKERRQ(ierr);
          // Results
          nbActiveResults[tagS[STRESSTOTAL]] = 0;
          commonData.stressTotal.resize(nbGaussPts);
          commonData.stressTotal[0].resize(3,3,false);
          for(int d1 = 0;d1<3;d1++) {
            for(int d2 = 0;d2<3;d2++) {
              cE->stressTotal(d1,d2) >>= (commonData.stressTotal[0])(d1,d2);
              nbActiveResults[tagS[STRESSTOTAL]]++;
            }
          }
        }
        trace_off();
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }

    PetscErrorCode recordSolventFlux() {
      PetscFunctionBegin;

      try {
        if(tagS[SOLVENTFLUX]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        cE->gradientMu.resize(3,false);
        ublas::matrix<double> &gradient_mu = (commonData.gradAtGaussPts[commonData.muName])[0];
        trace_on(tagS[SOLVENTFLUX]);
        {
          // Activate rate of gradient of defamation
          nbActiveVariables[tagS[SOLVENTFLUX]] = 0;
          for(int ii = 0;ii<3;ii++) {
            cE->gradientMu[ii] <<= gradient_mu(0,ii);
            nbActiveVariables[tagS[SOLVENTFLUX]]++;
          }
          ierr = cE->calculateSolventFlux(); CHKERRQ(ierr);
          nbActiveResults[tagS[SOLVENTFLUX]] = 0;
          commonData.solventFlux.resize(nbGaussPts);
          commonData.solventFlux[0].resize(3,false);
          for(int d1 = 0;d1<3;d1++) {
            cE->solventFlux[d1] >>= commonData.solventFlux[0][d1];
            nbActiveResults[tagS[SOLVENTFLUX]]++;
          }
        }
        trace_off();
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode recordVolumeDot() {
      PetscFunctionBegin;

      if(tagS[VOLUMERATE]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
      ublas::matrix<double> &F_dot = (commonData.gradAtGaussPts[commonData.spatialPositionNameDot])[0];

      trace_on(tagS[VOLUMERATE]);
      {
        // Activate rate of gradient of defamation
        nbActiveVariables[tagS[VOLUMERATE]] = 0;
        cE->F.resize(3,3,false);
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE->F(dd1,dd2) <<= F(dd1,dd2);
            nbActiveVariables[tagS[VOLUMERATE]]++;
          }
        }
        cE->FDot.resize(3,3,false);
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE->FDot(dd1,dd2) <<= F_dot(dd1,dd2);
            nbActiveVariables[tagS[VOLUMERATE]]++;
          }
        }
        ierr = cE->calculateTraceStrainTotalDot(); CHKERRQ(ierr);
        ierr = cE->calculateVolumeDot(); CHKERRQ(ierr);
        nbActiveResults[tagS[VOLUMERATE]] = 0;
        commonData.volumeDot.resize(nbGaussPts);
        cE->volumeDot >>= commonData.volumeDot[0];
        nbActiveResults[tagS[VOLUMERATE]]++;
      }
      trace_off();

      PetscFunctionReturn(0);
    }

    PetscErrorCode recordResidualStrainHat() {
      PetscFunctionBegin;

      if(tagS[RESIDUALSTRAINHAT]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      cE->F.resize(3,3,false);
      cE->strainHat.resize(3,3,false);
      cE->strainHatDot.resize(3,3,false);
      ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[0];
      ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[0];
      ublas::vector<double> &strain_hat_dot = (commonData.dataAtGaussPts[commonData.strainHatNameDot])[0];
      trace_on(tagS[RESIDUALSTRAINHAT]);
      {
        // Activate gradient of defamation
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] = 0;
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            cE->F(dd1,dd2) <<= F(dd1,dd2);
            nbActiveVariables[tagS[RESIDUALSTRAINHAT]]++;
          }
        }
        // Using vector notation to store hatStrain
        // xx,yy,zz,2xy,2yz,2zy
        cE->strainHat(0,0) <<= strain_hat[0];
        cE->strainHat(1,1) <<= strain_hat[1];
        cE->strainHat(2,2) <<= strain_hat[2];
        cE->strainHat(0,1) <<= strain_hat[3];
        cE->strainHat(1,2) <<= strain_hat[4];
        cE->strainHat(0,2) <<= strain_hat[5];
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] += 6;
        cE->strainHat(1,0) = cE->strainHat(0,1);
        cE->strainHat(2,1) = cE->strainHat(1,2);
        cE->strainHat(2,0) = cE->strainHat(0,2);
        // Activate strain hat dot
        cE->strainHatDot(0,0) <<= strain_hat_dot[0];
        cE->strainHatDot(1,1) <<= strain_hat_dot[1];
        cE->strainHatDot(2,2) <<= strain_hat_dot[2];
        cE->strainHatDot(0,1) <<= strain_hat_dot[3];
        cE->strainHatDot(1,2) <<= strain_hat_dot[4];
        cE->strainHatDot(0,2) <<= strain_hat_dot[5];
        nbActiveVariables[tagS[RESIDUALSTRAINHAT]] += 6;
        cE->strainHatDot(1,0) = cE->strainHatDot(0,1);
        cE->strainHatDot(2,1) = cE->strainHatDot(1,2);
        cE->strainHatDot(2,0) = cE->strainHatDot(0,2);
        ierr = cE->calculateStrainTotal(); CHKERRQ(ierr);
        ierr = cE->calculateStressBeta(); CHKERRQ(ierr);
        ierr = cE->calculateStrainHatFlux(); CHKERRQ(ierr);
        ierr = cE->calculateResidualStrainHat(); CHKERRQ(ierr);
        nbActiveResults[tagS[RESIDUALSTRAINHAT]] = 0;
        commonData.residualStrainHat.resize(nbGaussPts);
        commonData.residualStrainHat[0].resize(3,3,false);
        for(int d1 = 0;d1<3;d1++) {
          for(int d2 = d1;d2<3;d2++) {
            cE->residualStrainHat(d1,d2) >>= commonData.residualStrainHat[0](d1,d2);
            nbActiveResults[tagS[RESIDUALSTRAINHAT]]++;
          }
        }
      }
      trace_off();

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateFunction(TagEvaluate te,double *ptr) {
      PetscFunctionBegin;

      int r;
      //play recorder for values
      r = ::function(
        tagS[te],
        nbActiveResults[tagS[te]],
        nbActiveVariables[tagS[te]],
        &activeVariables[0],
        ptr
      );
      if(r<3) { // function is locally analytic
        SETERRQ1(PETSC_COMM_SELF,MOFEM_OPERATION_UNSUCCESSFUL,"ADOL-C function evaluation with error r = %d",r);
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateJacobian(TagEvaluate te) {
      PetscFunctionBegin;

      int r;
      r = jacobian(
        tagS[te],
        nbActiveResults[tagS[te]],
        nbActiveVariables[tagS[te]],
        &activeVariables[0],
        &(commonData.jacRowPtr[0])
      );
      if(r<3) {
        SETERRQ(PETSC_COMM_SELF,MOFEM_OPERATION_UNSUCCESSFUL,"ADOL-C function evaluation with error");
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsStressTotal() {
      PetscFunctionBegin;

      try {

        if(tagS[STRESSTOTAL]<0) {
          PetscFunctionReturn(0);
        }


        PetscErrorCode ierr;

        activeVariables.resize(nbActiveVariables[tagS[STRESSTOTAL]],false);

        for(int gg = 0;gg<nbGaussPts;gg++) {

          ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
          ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[gg];
          double mu = (commonData.dataAtGaussPts[commonData.muName])[gg][0];

          int nb_active_variables = 0;
          // Activate gradient of defamation
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              activeVariables[nb_active_variables++] = F(dd1,dd2);
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat[ii];
          }
          activeVariables[nb_active_variables++] = mu;

          if(nb_active_variables!=nbActiveVariables[tagS[STRESSTOTAL]]) {
            SETERRQ(
              PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
            );
          }

          if(calculateResidualBool) {
            commonData.stressTotal[gg].resize(3,3,false);
            ierr = calculateFunction(STRESSTOTAL,&commonData.stressTotal[gg](0,0)); CHKERRQ(ierr);
          }

          if(calculateJacobianBool) {

            if(gg == 0) {
              commonData.jacStressTotal.resize(nbGaussPts);
              commonData.jacRowPtr.resize(nbActiveResults[tagS[STRESSTOTAL]]);
            }
            commonData.jacStressTotal[gg].resize(
              nbActiveResults[tagS[STRESSTOTAL]],
              nbActiveVariables[tagS[STRESSTOTAL]],
              false
            );
            for(int dd = 0;dd<nbActiveResults[tagS[STRESSTOTAL]];dd++) {
              commonData.jacRowPtr[dd] = &commonData.jacStressTotal[gg](dd,0);
            }

            ierr = calculateJacobian(STRESSTOTAL); CHKERRQ(ierr);

          }

        }

      } catch (const std::exception& ex) {
          ostringstream ss;
          ss << "throw in method: " << ex.what() << endl;
          SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
        }


      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsSolventFlux() {
      PetscFunctionBegin;

      if(tagS[SOLVENTFLUX]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      activeVariables.resize(nbActiveResults[tagS[SOLVENTFLUX]]);

      for(int gg = 0;gg<nbGaussPts;gg++) {

        ublas::matrix<double> &gradient_mu = (commonData.gradAtGaussPts[commonData.muName])[gg];

        int nb_active_variables = 0;
        // Activate rate of gradient of defamation
        for(int ii = 0;ii<3;ii++) {
          activeVariables[nb_active_variables++] = gradient_mu(0,ii);
        }

        if(nb_active_variables!=nbActiveVariables[tagS[SOLVENTFLUX]]) {
          SETERRQ(
            PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
          );
        }

        if(calculateResidualBool) {
          commonData.solventFlux[gg].resize(3,false);
          ierr = calculateFunction(
            SOLVENTFLUX,
            &(commonData.solventFlux[gg][0])
          ); CHKERRQ(ierr);
        }

        if(calculateJacobianBool) {
          if(gg == 0) {
            commonData.jacSolventFlux.resize(nbGaussPts);
            commonData.jacRowPtr.resize(nbActiveResults[tagS[SOLVENTFLUX]]);
          }
          commonData.jacSolventFlux[gg].resize(
            nbActiveResults[tagS[SOLVENTFLUX]],
            nbActiveVariables[tagS[SOLVENTFLUX]],
            false
          );
          for(int dd = 0;dd<nbActiveResults[tagS[SOLVENTFLUX]];dd++) {
            commonData.jacRowPtr[dd] = &(commonData.jacSolventFlux[gg](dd,0));
          }
          ierr = calculateJacobian(SOLVENTFLUX); CHKERRQ(ierr);

        }
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtsVolumeDot() {
      PetscFunctionBegin;

      if(tagS[VOLUMERATE]<0) {
        PetscFunctionReturn(0);
      }

      PetscErrorCode ierr;

      activeVariables.resize(nbActiveVariables[tagS[VOLUMERATE]],false);

      for(int gg = 0;gg<nbGaussPts;gg++) {
        ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
        ublas::matrix<double> &F_dot = (commonData.gradAtGaussPts[commonData.spatialPositionNameDot])[gg];
        int nb_active_variables = 0;
        // Activate gradient of defamation
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            activeVariables[nb_active_variables++] = F(dd1,dd2);
          }
        }
        for(int dd1 = 0;dd1<3;dd1++) {
          for(int dd2 = 0;dd2<3;dd2++) {
            activeVariables[nb_active_variables++] = F_dot(dd1,dd2);
          }
        }
        if(nb_active_variables!=nbActiveVariables[tagS[VOLUMERATE]]) {
          SETERRQ(
            PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
          );
        }
        if(calculateResidualBool) {
          ierr = calculateFunction(VOLUMERATE,&commonData.stressTotal[gg](0,0)); CHKERRQ(ierr);
        }
        if(calculateJacobianBool) {
          if(gg == 0) {
            commonData.jacVolumeRate.resize(nbGaussPts);
            commonData.jacRowPtr.resize(nbActiveResults[tagS[VOLUMERATE]]);
          }
          commonData.jacVolumeRate[gg].resize(nbActiveVariables[tagS[VOLUMERATE]]);
          commonData.jacRowPtr[0] = &commonData.jacVolumeRate[gg][0];
          ierr = calculateJacobian(VOLUMERATE); CHKERRQ(ierr);
        }
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode calculateAtIntPtrsResidualStrainHat() {
      PetscFunctionBegin;

      try {
        if(tagS[RESIDUALSTRAINHAT]<0) {
          PetscFunctionReturn(0);
        }
        PetscErrorCode ierr;
        activeVariables.resize(nbActiveVariables[tagS[RESIDUALSTRAINHAT]]);
        for(int gg = 0;gg<nbGaussPts;gg++) {
          ublas::matrix<double> &F = (commonData.gradAtGaussPts[commonData.spatialPositionName])[gg];
          ublas::vector<double> &strain_hat = (commonData.dataAtGaussPts[commonData.strainHatName])[gg];
          ublas::vector<double> &strain_hat_dot = (commonData.dataAtGaussPts[commonData.strainHatNameDot])[gg];
          int nb_active_variables = 0;
          // Activate gradient of defamation
          for(int dd1 = 0;dd1<3;dd1++) {
            for(int dd2 = 0;dd2<3;dd2++) {
              activeVariables[nb_active_variables++] = F(dd1,dd2);
            }
          }
          // Using vector notation to store hatStrain
          // xx,yy,zz,2xy,2yz,2zy
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat[ii];
          }
          // Using vector notation to store hatStrainDot
          for(int ii = 0;ii<6;ii++) {
            activeVariables[nb_active_variables++] = strain_hat_dot[ii];
          }
          if(nb_active_variables!=nbActiveVariables[tagS[RESIDUALSTRAINHAT]]) {
            SETERRQ(
              PETSC_COMM_SELF,MOFEM_IMPOSIBLE_CASE,"Number of active variables does not much"
            );
          }
          if(calculateResidualBool) {
            commonData.residualStrainHat[gg].resize(3,3,false);
            ierr = calculateFunction(
              RESIDUALSTRAINHAT,&commonData.residualStrainHat[gg](0,0)
            ); CHKERRQ(ierr);
          }
          if(calculateJacobianBool) {
            if(gg == 0) {
              commonData.jacStrainHat.resize(nbGaussPts);
              commonData.jacRowPtr.resize(nbActiveResults[tagS[RESIDUALSTRAINHAT]]);
            }
            commonData.jacStrainHat[gg].resize(
              nbActiveResults[tagS[RESIDUALSTRAINHAT]],
              nbActiveVariables[tagS[RESIDUALSTRAINHAT]],
              false
            );
            for(int dd = 0;dd<nbActiveResults[tagS[RESIDUALSTRAINHAT]];dd++) {
              commonData.jacRowPtr[dd] = &commonData.jacStrainHat[gg](dd,0);
            }
            ierr = calculateJacobian(RESIDUALSTRAINHAT); CHKERRQ(ierr);
          }
        }


      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      PetscErrorCode ierr;

      if(row_type != MBVERTEX) PetscFunctionReturn(0);
      nbGaussPts = row_data.getN().size1();

      try {

        if(recordOn) {
          ierr = recordStressTotal(); CHKERRQ(ierr);
          ierr = recordSolventFlux(); CHKERRQ(ierr);
          ierr = recordVolumeDot(); CHKERRQ(ierr);
          ierr = recordResidualStrainHat(); CHKERRQ(ierr);
        }

        ierr = calculateAtIntPtsStressTotal(); CHKERRQ(ierr);
        ierr = calculateAtIntPtsSolventFlux(); CHKERRQ(ierr);
        ierr = calculateAtIntPtsVolumeDot(); CHKERRQ(ierr);
        ierr = calculateAtIntPtrsResidualStrainHat(); CHKERRQ(ierr);

      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }

      PetscFunctionReturn(0);
    }

  };

  struct AssembleVector: VolumeElementForcesAndSourcesCore::UserDataOperator {
    AssembleVector(string field_name):
    VolumeElementForcesAndSourcesCore::UserDataOperator(field_name,UserDataOperator::OPROW) {
    }
    PetscErrorCode ierr;
    ublas::vector<double> nF;
    PetscErrorCode aSemble(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        int *indices_ptr = &row_data.getIndices()[0];
        ierr = VecSetValues(
          getFEMethod()->ts_F,nb_dofs,indices_ptr,&nF[0],ADD_VALUES
        ); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble internal force vector
  \ingroup gel

  \f[
  (\mathbf{f}^\textrm{internal}_x)_i =
  \int_V
  \frac{\partial N_i}{\partial X_j} \sigma_{ij}
  \textrm{d}V
  \f]

  */
  struct OpRhsStressTotal: public AssembleVector {
    CommonData &commonData;
    OpRhsStressTotal(CommonData &common_data):
    AssembleVector(common_data.spatialPositionName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_dofs/3);
          const ublas::matrix<double>& stress = commonData.stressTotal[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs/3;dd++) {
            for(int rr = 0;rr<3;rr++) {
              for(int nn = 0;nn<3;nn++) {
                nF[3*dd+rr] += val*diffN(dd,nn)*stress(rr,nn);
              }
            }
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Calculate internal forces for solvent flux
  \ingroup gel

  \f[
  (\mathbf{f}^J_{\mu})_j =
  \int_V
  \frac{\partial N_j}{\partial X_k} J_k
  \textrm{d}V
  \f]

  */
  struct OpRhsSolventFlux: public AssembleVector {
    CommonData &commonData;
    OpRhsSolventFlux(CommonData &common_data):
    AssembleVector(common_data.muName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_dofs);
          const ublas::vector<double>& flux = commonData.solventFlux[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs;dd++) {
            for(int nn = 0;nn<3;nn++) {
              nF[dd] += val*diffN(dd,nn)*flux(nn);
            }
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Calculating right hand side
  \ingroup gel

  \f[
  (\mathbf{f}^V_\mu)_j =
  \int_V
  N_j \frac{\partial V}{\partial t}
  \textrm{d}V
  \f]

  */
  struct OpRhsVolumeDot: public AssembleVector {
    CommonData &commonData;
    OpRhsVolumeDot(CommonData &common_data):
    AssembleVector(common_data.muName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const VectorAdaptor &N = row_data.getN(gg,nb_dofs);
          double volume_dot = commonData.volumeDot[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          nF += val*N*volume_dot;
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Residual strain hat
  \ingroup gel

  \f[
  (\mathbf{r}_{\hat{\varepsilon}})_j =
  \int_V
  N_j \left(
  \frac{\partial \hat{\varepsilon}}{\partial t}-
  f(\sigma^\beta)
  \right)
  \textrm{d}V
  \f]

  */
  struct OpRhsStrainHat: public AssembleVector {
    CommonData &commonData;
    OpRhsStrainHat(CommonData &common_data):
    AssembleVector(common_data.strainHatName),
    commonData(common_data) {
    }
    PetscErrorCode doWork(
      int row_side,EntityType row_type,DataForcesAndSurcesCore::EntData &row_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_dofs = row_data.getIndices().size();
        if(!nb_dofs) {
          PetscFunctionReturn(0);
        }
        nF.resize(nb_dofs,false);
        nF.clear();
        int nb_gauss_pts = row_data.getN().size1();
        for(int gg = 0;gg<nb_gauss_pts;gg++) {
          const VectorAdaptor &N = row_data.getN(gg,nb_dofs/6);
          ublas::matrix<double> strain_hat = commonData.residualStrainHat[gg];
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          for(int dd = 0;dd<nb_dofs/6;dd++) {
            nF[dd*6+0] += val*N[dd]*strain_hat(0,0);
            nF[dd*6+1] += val*N[dd]*strain_hat(1,1);
            nF[dd*6+2] += val*N[dd]*strain_hat(2,2);
            nF[dd*6+3] += val*N[dd]*strain_hat(0,1);
            nF[dd*6+4] += val*N[dd]*strain_hat(1,2);
            nF[dd*6+5] += val*N[dd]*strain_hat(0,2);
          }
        }
        ierr = aSemble(row_side,row_type,row_data); CHKERRQ(ierr);
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  struct AssembleMatrix: VolumeElementForcesAndSourcesCore::UserDataOperator {
    AssembleMatrix(string row_name,string col_name):
    VolumeElementForcesAndSourcesCore::UserDataOperator(
      row_name,col_name,UserDataOperator::OPROWCOL) {
    }
    PetscErrorCode ierr;
    ublas::matrix<double> K,transK;
    PetscErrorCode aSemble(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      try {
        int nb_row = row_data.getIndices().size();
        int nb_col = col_data.getIndices().size();
        int *row_indices_ptr = &row_data.getIndices()[0];
        int *col_indices_ptr = &col_data.getIndices()[0];
        ierr = MatSetValues(
          getFEMethod()->ts_B,
          nb_row,row_indices_ptr,
          nb_col,col_indices_ptr,
          &K(0,0),ADD_VALUES
        ); CHKERRQ(ierr);
        if(sYmm) {
          // Assemble of diagonal terms
          if(row_side != col_side || row_type != col_type) {
            transK.resize(nb_col,nb_row,false);
            noalias(transK) = trans(K);
            ierr = MatSetValues(
              getFEMethod()->ts_B,
              nb_col,col_indices_ptr,
              nb_row,row_indices_ptr,
              &K(0,0),ADD_VALUES
            ); CHKERRQ(ierr);
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{xx}\f$
  */
  struct OpLhsdxdx: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdxdx(CommonData &common_data):
    AssembleMatrix(
      common_data.spatialPositionName,common_data.spatialPositionName
    ),
    commonData(common_data) {
    }
    ublas::matrix<double> dStress_dx;
    PetscErrorCode get_dStress_dx(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dStress_dx.resize(9,nb_col,false);
        dStress_dx.clear();
        const MatrixAdaptor diffN = col_data.getDiffN(gg,nb_col/3);
        ublas::matrix<double> &jac_stress = commonData.jacStressTotal[gg];
        // FIXME: This can be implemented more efficiently. At this stage is
        // efficiency bottle neck.
        for(int dd = 0;dd<nb_col/3;dd++) {  // DoFs in column
          for(int jj = 0;jj<3;jj++) {       // cont. DoFs in column
            double a = diffN(dd,jj);
            for(int rr = 0;rr<3;rr++) {     // Loop over dsigma_ii/dX_rr
              for(int ii = 0;ii<9;ii++) {   // ii represents components of stress tensor
                dStress_dx(ii,3*dd+rr) += jac_stress(ii,3*rr+jj)*a;
              }
            }
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dStress_dx(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dStress_dx *= val;
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_row/3);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row/3;dd1++) {
              for(int rr1 = 0;rr1<3;rr1++) {
                for(int dd2 = 0;dd2<nb_col/3;dd2++) {
                  for(int rr2 = 0;rr2<3;rr2++) {
                    K(3*dd1+rr1,3*dd2+rr2) +=
                    diffN(dd1,0)*dStress_dx(3*rr1+0,3*dd2+rr2)+
                    diffN(dd1,1)*dStress_dx(3*rr1+1,3*dd2+rr2)+
                    diffN(dd1,2)*dStress_dx(3*rr1+2,3*dd2+rr2);
                  }
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{x\mu}\f$
  */
  struct OpLhsdxdMu: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdxdMu(CommonData &common_data):
    AssembleMatrix(
      common_data.spatialPositionName,common_data.muName
    ),
    commonData(common_data) {
      sYmm = false;
    }
    ublas::matrix<double> dStress_dMu;
    PetscErrorCode get_dStress_dx(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dStress_dMu.resize(9,nb_col,false);
        dStress_dMu.clear();
        const VectorAdaptor N = col_data.getN(gg);
        ublas::matrix<double> &jac_stress = commonData.jacStressTotal[gg];
        for(int dd = 0;dd<nb_col;dd++) {
          double a = N[dd];
          for(int ii = 0;ii<9;ii++) {
            dStress_dMu(ii,dd) += jac_stress(ii,9+6+0)*a;
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dStress_dx(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dStress_dMu *= val;
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_row/3);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row/3;dd1++) {
              for(int rr1 = 0;rr1<3;rr1++) {
                for(int dd2 = 0;dd2<nb_col;dd2++) {
                  K(3*dd1+rr1,dd2) +=
                  diffN(dd1,0)*dStress_dMu(3*rr1+0,dd2)+
                  diffN(dd1,1)*dStress_dMu(3*rr1+1,dd2)+
                  diffN(dd1,2)*dStress_dMu(3*rr1+2,dd2);
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{x\hat{\varepsilon}}\f$
  */
  struct OpLhsdxdStrainHat: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdxdStrainHat(CommonData &common_data):
    AssembleMatrix(
      common_data.spatialPositionName,common_data.strainHatName
    ),
    commonData(common_data) {
      sYmm = false;
    }
    ublas::matrix<double> dStress_dStrainHat;
    PetscErrorCode get_dStress_dStrainHat(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dStress_dStrainHat.resize(9,nb_col,false);
        dStress_dStrainHat.clear();
        const VectorAdaptor N = col_data.getN(gg);
        ublas::matrix<double> &jac_stress = commonData.jacStressTotal[gg];
        /*cerr << N << endl;
        cerr << jac_stress << endl;
        cerr << dStress_dStrainHat << endl;
        cerr << nb_col << endl;*/
        for(int dd = 0;dd<nb_col/6;dd++) {  /// DoFS in column
          double a = N[dd];
          for(int ii = 0;ii<9;ii++) {   // ii for elements in stress matrix
            for(int rr = 0;rr<6;rr++) {
              dStress_dStrainHat(ii,6*dd+rr) += jac_stress(ii,9+rr)*a;
            }
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dStress_dStrainHat(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dStress_dStrainHat *= val;
          const MatrixAdaptor &diffN = row_data.getDiffN(gg,nb_row/3);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row/3;dd1++) {
              for(int rr1 = 0;rr1<3;rr1++) {
                for(int dd2 = 0;dd2<nb_col/6;dd2++) {
                  for(int rr2 = 0;rr2<6;rr2++) {
                    K(3*dd1+rr1,6*dd2+rr2) +=
                    diffN(dd1,0)*dStress_dStrainHat(3*rr1+0,6*dd2+rr2)+
                    diffN(dd1,1)*dStress_dStrainHat(3*rr1+1,6*dd2+rr2)+
                    diffN(dd1,2)*dStress_dStrainHat(3*rr1+2,6*dd2+rr2);
                  }
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{\hat{\varepsilon}\hat{\varepsilon}}\f$
  */
  struct OpLhsdStrainHatdStrainHat: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdStrainHatdStrainHat(CommonData &common_data):
    AssembleMatrix(
      common_data.strainHatName,common_data.strainHatName
    ),
    commonData(common_data) {
    }
    ublas::matrix<double> dStrainHat_dStrainHat;
    PetscErrorCode get_dStrainHat_dStrainHat(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dStrainHat_dStrainHat.resize(6,nb_col,false);
        dStrainHat_dStrainHat.clear();
        const VectorAdaptor N = col_data.getN(gg);
        ublas::matrix<double> &jac_res_strain_hat = commonData.jacStrainHat[gg];
        for(int dd = 0;dd<nb_col/6;dd++) {  /// DoFS in column
          double a = N[dd];
          for(int ii = 0;ii<6;ii++) {   // ii for elements in stress matrix
            for(int rr = 0;rr<6;rr++) {
              dStrainHat_dStrainHat(ii,6*dd+rr) += jac_res_strain_hat(ii,9+rr)*a;
              dStrainHat_dStrainHat(ii,6*dd+rr) += jac_res_strain_hat(ii,9+6+rr)*a*getFEMethod()->ts_a; // Time dependent element
            }
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dStrainHat_dStrainHat(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dStrainHat_dStrainHat *= val;
          const VectorAdaptor &N = row_data.getN(gg);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row/6;dd1++) {
              for(int rr1 = 0;rr1<6;rr1++) {
                for(int dd2 = 0;dd2<nb_col;dd2++) {
                  K(6*dd1+rr1,dd2) += N[dd1]*dStrainHat_dStrainHat(rr1,dd2);
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{\hat{\varepsilon}x}\f$
  */
  struct OpLhsdStrainHatdx: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdStrainHatdx(CommonData &common_data):
    AssembleMatrix(
      common_data.strainHatName,common_data.spatialPositionName
    ),
    commonData(common_data) {
      sYmm = false;
    }
    ublas::matrix<double> dStrainHat_dx;
    PetscErrorCode get_dStrainHat_dx(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dStrainHat_dx.resize(6,nb_col,false);
        dStrainHat_dx.clear();
        const MatrixAdaptor diffN = col_data.getDiffN(gg,nb_col/3);
        ublas::matrix<double> &jac_res_strain_hat = commonData.jacStrainHat[gg];
        //cerr << "a\n" << diffN << endl;
        //cerr << "b\n" << jac_res_strain_hat << endl;
        for(int dd = 0;dd<nb_col/3;dd++) {    // DoFs in column
          for(int rr1 = 0;rr1<3;rr1++) {      // cont. DoFs in column
            double a = diffN(dd,rr1);
            for(int ii = 0;ii<6;ii++) {       // ii for elements in strain hat
              for(int rr2 = 0;rr2<3;rr2++) {
                dStrainHat_dx(ii,3*dd+rr2) += jac_res_strain_hat(ii,3*rr2+rr1)*a;
              }
            }
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dStrainHat_dx(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dStrainHat_dx *= val;
          //cerr << dStrainHat_dx << endl;
          const VectorAdaptor &N = row_data.getN(gg);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row/6;dd1++) {
              for(int rr1 = 0;rr1<6;rr1++) {
                for(int dd2 = 0;dd2<nb_col/3;dd2++) {
                  for(int rr2 = 0;rr2<3;rr2++) {
                    K(6*dd1+rr1,3*dd2+rr2) += N[dd1]*dStrainHat_dx(rr1,3*dd2+rr2);
                  }
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };

  /** \brief Assemble matrix \f$\mathbf{K}_{\mu \mu}\f$
  */
  struct OpLhsdMudMu: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdMudMu(CommonData &common_data):
    AssembleMatrix(
      common_data.muName,common_data.muName
    ),
    commonData(common_data) {
    }
    ublas::matrix<double> dSolventFlux_dmu;
    PetscErrorCode get_dSolventFlux_dmu(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dSolventFlux_dmu.resize(3,nb_col,false);
        dSolventFlux_dmu.clear();
        const MatrixAdaptor diffN = col_data.getDiffN(gg);
        ublas::matrix<double> &jac_solvent_flux = commonData.jacSolventFlux[gg];
        for(int dd = 0;dd<nb_col;dd++) {    // DoFs in column
          for(int rr1 = 0;rr1<3;rr1++) {
            double a = diffN(dd,rr1);
            for(int rr2 = 0;rr2<3;rr2++) {
              dSolventFlux_dmu(rr2,dd) += jac_solvent_flux(rr2,rr1)*a;
            }
          }
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dSolventFlux_dmu(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dSolventFlux_dmu *= val;
          //cerr << dSolventFlux_dmu << endl;
          const MatrixAdaptor &diffN = row_data.getDiffN(gg);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row;dd1++) {
              for(int dd2 = 0;dd2<nb_col;dd2++) {
                for(int rr = 0;rr<3;rr++) {
                  K(dd1,dd2) += diffN(dd1,rr)*dSolventFlux_dmu(rr,dd2);
                }
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };


  /** \brief Assemble matrix \f$\mathbf{K}_{\mu x}\f$
  */
  struct OpLhsdMudx: public AssembleMatrix {
    CommonData &commonData;
    OpLhsdMudx(CommonData &common_data):
    AssembleMatrix(
      common_data.muName,common_data.spatialPositionName
    ),
    commonData(common_data) {
      sYmm = false;
    }
    ublas::vector<double> dSolventFlux_dx;
    PetscErrorCode get_dSolventFlux_dx(
      DataForcesAndSurcesCore::EntData &col_data,int gg
    ) {
      PetscFunctionBegin;
      try {
        int nb_col = col_data.getIndices().size();
        dSolventFlux_dx.resize(nb_col,false);
        dSolventFlux_dx.clear();
        const MatrixAdaptor diffN = col_data.getDiffN(gg);
        ublas::vector<double> &jac_volume_rate = commonData.jacVolumeRate[gg];
        //cerr << jac_volume_rate << endl;
        for(int dd = 0;dd<nb_col/3;dd++) {    // DoFs in column
          for(int rr1 = 0;rr1<3;rr1++) {
            double a = diffN(dd,rr1);
            for(int rr2 = 0;rr2<3;rr2++) {
              dSolventFlux_dx[3*dd+rr2] += jac_volume_rate(3*rr2+rr1)*a;
              dSolventFlux_dx[3*dd+rr2] += jac_volume_rate(9+3*rr2+rr1)*a*getFEMethod()->ts_a;
            }
          }
        }
        //cerr << dSolventFlux_dx << endl;
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
    PetscErrorCode doWork(
      int row_side,int col_side,
      EntityType row_type,EntityType col_type,
      DataForcesAndSurcesCore::EntData &row_data,
      DataForcesAndSurcesCore::EntData &col_data
    ) {
      PetscFunctionBegin;
      int nb_row = row_data.getIndices().size();
      int nb_col = col_data.getIndices().size();
      if(nb_row == 0) PetscFunctionReturn(0);
      if(nb_col == 0) PetscFunctionReturn(0);
      try {
        K.resize(nb_row,nb_col,false);
        K.clear();
        for(unsigned int gg = 0;gg<row_data.getN().size1();gg++) {
          ierr = get_dSolventFlux_dx(col_data,gg); CHKERRQ(ierr);
          double val = getVolume()*getGaussPts()(3,gg);
          if(getHoGaussPtsDetJac().size()>0) {
            val *= getHoGaussPtsDetJac()[gg]; ///< higher order geometry
          }
          dSolventFlux_dx *= val;
          //cerr << dSolventFlux_dx << endl;
          const VectorAdaptor &N = row_data.getN(gg);
          { //integrate element stiffness matrix
            for(int dd1 = 0;dd1<nb_row;dd1++) {
              for(int dd2 = 0;dd2<nb_col;dd2++) {
                K(dd1,dd2) += N[dd1]*dSolventFlux_dx[dd2];
              }
            }
          }
          ierr = aSemble(
            row_side,col_side,row_type,col_type,row_data,col_data
          ); CHKERRQ(ierr);
        }
      } catch (const std::exception& ex) {
        ostringstream ss;
        ss << "throw in method: " << ex.what() << endl;
        SETERRQ(PETSC_COMM_SELF,1,ss.str().c_str());
      }
      PetscFunctionReturn(0);
    }
  };


  struct MonitorPostProc: public FEMethod {

    FieldInterface &mField;
    string pRoblem;
    string fE;
    CommonData &commonData;
    PostPocOnRefinedMesh postProc;

    bool iNit;
    int pRT;

    MonitorPostProc(
      FieldInterface &m_field,string problem,string fe,CommonData &common_data
    ):
    FEMethod(),
    mField(m_field),
    pRoblem(problem),
    fE(fe),
    commonData(common_data),
    postProc(m_field),
    iNit(false) {
      PetscErrorCode ierr;
      PetscBool flg = PETSC_TRUE;
      ierr = PetscOptionsGetInt(
        PETSC_NULL,"-my_output_prt",&pRT,&flg
      ); CHKERRABORT(PETSC_COMM_WORLD,ierr);
      if(flg!=PETSC_TRUE) {
        pRT = 1;
      }
    }

    PetscErrorCode preProcess() {
      PetscFunctionBegin;
      PetscFunctionReturn(0);
    }

    PetscErrorCode operator()() {
      PetscFunctionBegin;
      PetscFunctionReturn(0);
    }

    PetscErrorCode postProcess() {
      PetscFunctionBegin;

      PetscErrorCode ierr;
      ierr = mField.set_other_local_ghost_vector(
        problemPtr,commonData.spatialPositionName,commonData.spatialPositionNameDot,ROW,ts_u_t,INSERT_VALUES,SCATTER_REVERSE
      ); CHKERRQ(ierr);
      ierr = mField.set_other_local_ghost_vector(
        problemPtr,commonData.muName,commonData.muNameDot,ROW,ts_u_t,INSERT_VALUES,SCATTER_REVERSE
      ); CHKERRQ(ierr);
      ierr = mField.set_other_local_ghost_vector(
        problemPtr,commonData.strainHatName,commonData.strainHatNameDot,ROW,ts_u_t,INSERT_VALUES,SCATTER_REVERSE
      ); CHKERRQ(ierr);

      if(!iNit) {
        ierr = postProc.generateReferenceElementMesh(); CHKERRQ(ierr);
        ierr = postProc.addFieldValuesPostProc(commonData.spatialPositionName); CHKERRQ(ierr);
        ierr = postProc.addFieldValuesPostProc(commonData.muName); CHKERRQ(ierr);
        ierr = postProc.addFieldValuesPostProc(commonData.strainHatName); CHKERRQ(ierr);
        iNit = true;
      }
      int step;
      ierr = TSGetTimeStepNumber(ts,&step); CHKERRQ(ierr);
      ErrorCode rval;
      if((step)%pRT==0) {
        ierr = mField.loop_finite_elements(pRoblem,fE,postProc); CHKERRQ(ierr);
        ostringstream sss;
        sss << "out_" << step << ".h5m";
        rval = postProc.postProcMesh.write_file(sss.str().c_str(),"MOAB","PARALLEL=WRITE_PART"); CHKERR_PETSC(rval);
      }
      PetscFunctionReturn(0);
    }

  };

};

#endif //__GEL_HPP__

/***************************************************************************//**
 * \defgroup gel Gel model
 * \ingroup user_modules
 ******************************************************************************/
