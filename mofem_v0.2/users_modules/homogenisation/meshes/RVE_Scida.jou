#!python
#This scrip will create RVE including fibres and matrix, which can be used for all 
#three type of boundary conditions including dispalcement, traction and periodic. 

cubit.cmd('new')
#=============================================================
#Geometry Input parametrs
#=============================================================
a1=0.6
a2=0.6
a3=0.05
ag1=0.02
ag2=0.02

W_warp=a2-ag2/2
W_weft=a1-ag1/2

L_RVE=4*a2
W_RVE=4*a1
H_RVE=2.28*a3 

dy_w=W_warp/100
dy_g=ag2/50   
dx_w=W_weft/100
dx_g=ag1/50  

autofactor=7; 
 
#=============================================================
#Create vartices for splines to create splines
#=============================================================

import math
da3=0.003;
a3=a3+da3;
#---------------------
# Fill 1 path (14) top
#---------------------
coordx=-a1
coordy=-3*a2-dy_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordy=coordy+dy_w;
    else:
        coordy=coordy+dy_g;
    coordz=a3/2*(math.sin(-math.pi*(coordy)/(2*a2)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	


#---------------------
# Fill 2 path (12) top
#---------------------		
coordx=a1
coordy=-3*a2-dy_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordy=coordy+dy_w;
    else:
        coordy=coordy+dy_g;
    coordz=a3/2*(math.sin(math.pi*(coordy)/(2*a2)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	
		
#---------------------
# Warp 1 path (2) top
#---------------------
coordy=-a2
coordx=-3*a1-dx_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordx=coordx+dx_w;
    else:
        coordx=coordx+dx_g;
    coordz=a3/2*(math.sin(math.pi*(coordx)/(2*a1)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

#---------------------
# Warp 2 path (8) top
#---------------------
coordy=a2
coordx=-3*a1-dx_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordx=coordx+dx_w;
    else:
        coordx=coordx+dx_g;
    coordz=a3/2*(math.sin(-math.pi*(coordx)/(2*a1)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)			

#=============================================================
#Joint vertices to create splines 
#=============================================================

Tvertices=751;  
vertices=range(1,Tvertices+1); count1=0;   
for i in range(0, 4): 
    str1='create curve spline vertex '
    for j in range(0, 751):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+751;   

#=============================================================
#Creating yarns/inclusions with sinusoidal cross sections  
#=============================================================

a3=a3-da3;
#-------------------------------------
# Fill 1 front surface top profile (1)
#-------------------------------------
coordy=3*a2
coordx=-2*a1+ag1/2-dx_w
A_coef=-a3/2*math.sin(math.pi*ag1/4/a1)-a3/2
B_coef=math.pi/(ag1-2*a1)
C_coef=-math.pi*(ag1-4*a1)/2/(ag1-2*a1)
D_coef=-a3/2*math.sin(math.pi*ag1/4/a1)+a3/2 
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)

#----------------------------------------
# Fill 1 front surface bottom profile (2)
#----------------------------------------	
A_coef=a3/2
B_coef=math.pi/(2*a1)
C_coef=0
D_coef=a3/2
coordy=3*a2
coordx=-2*a1+ag1/2-dx_w	
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)    	

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3004;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;

#-------------------------------------
# Fill 2 front surface top profile (5)
#-------------------------------------
coordy=3*a2
coordx=ag1/2-dx_w
A_coef=a3/2
B_coef=math.pi/(2*a1)
C_coef=0
D_coef=-a3/2
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef;
    coordz=coordz;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

#----------------------------------------
# Fill 2 front surface bottom profile (6)
#----------------------------------------
coordy=3*a2
coordx=ag1/2-dx_w
A_coef=-a3/2*math.sin(math.pi*ag1/4/a1)-a3/2
B_coef=math.pi/(ag1-2*a1)
C_coef=math.pi*(ag1-4*a1)/2/(ag1-2*a1)
D_coef=a3/2*math.sin(math.pi*ag1/4/a1)-a3/2 
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef;
    coordz=coordz;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3406;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;	

#-------------------------------------
# Wrap 1 front surface top profile (9)
#-------------------------------------

coordx=3*a1
coordy=-2*a2+ag2/2-dy_w

A_coef=a3/2
B_coef=-math.pi/(2*a2)
C_coef=0
D_coef=-a3/2
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef 
    coordz=coordz;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)
#-----------------------------------------
# Warp 1 front surface bottom profile (10)
#-----------------------------------------	
coordx=3*a1
coordy=-2*a2+ag2/2-dy_w	
A_coef=-a3/2*math.sin(math.pi*ag2/4/a2)-a3/2
B_coef=-math.pi/(ag2-2*a2)
C_coef=math.pi*(ag2-4*a2)/2/(ag2-2*a2)
D_coef=a3/2*math.sin(math.pi*ag2/4/a2)-a3/2 
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef; 
    coordz=coordz;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)  

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3808;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;
    

#-------------------------------------
# Wrap 2 front surface top profile (13)
#-------------------------------------
coordx=3*a1
coordy=ag2/2-dy_w
A_coef=-a3/2*math.sin(math.pi*ag2/4/a2)-a3/2
B_coef=-math.pi/(ag2-2*a2)
C_coef=-math.pi*(ag2-4*a2)/2/(ag2-2*a2)
D_coef=-a3/2*math.sin(math.pi*ag2/4/a2)+a3/2 
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)

#-----------------------------------------
# Warp 2 front surface bottom profile (14)
#-----------------------------------------	
coordx=3*a1
coordy=ag2/2-dy_w	
A_coef=a3/2
B_coef=-math.pi/(2*a2)
C_coef=0
D_coef=a3/2
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef
    coordz=coordz+da3;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)  	
 
Tvertices=201;  
vertices=range(1,Tvertices+1); count1=4210;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;
 

# Create yarn cross-section and 
#        sweep along guideline/path to generate yarn volume
# 

# Fill/weft 1-2
cubit.cmd('create surface curve 5 6')  
cubit.cmd('create surface curve 7 8') 
# Warp 1-2
cubit.cmd('create surface curve 9 10')  
cubit.cmd('create surface curve 11 12')  
#
cubit.cmd('sweep surface 1 along curve 1')   
cubit.cmd('sweep surface 2 along curve 2') 
cubit.cmd('sweep surface 3 along curve 3')   
cubit.cmd('sweep surface 4 along curve 4') 	

#=============================================================
#Deletion of remaining free vertices, curves and bodies 
#=============================================================

cubit.cmd('delete vertex all')
cubit.cmd('delete curve all')

#=============================================================
#Create matrix and imprint and merge fibres and matrix to create common surfaces
#=============================================================

str1='brick x '+str(L_RVE)+' y '+str(W_RVE)+' z '+str(H_RVE); cubit.cmd(str1) 

cubit.cmd('intersect volume all keep')
cubit.cmd('subtract volume 6 7 8 9 from volume 5 keep')
cubit.cmd('delete volume 1 2 3 4 5')
cubit.cmd('imprint volume 6 7 8 9 10')   
cubit.cmd('merge volume 6 7 8 9 10') 

#=============================================================
#Meshing negative x, y and z face of the RVE and coping the same to its positive faces
#=============================================================
# 1: +x 2: +y 3: +z
# 4: -x 5: -y 6: -z  
cubit.cmd('group "g1" add surface 34 38 52') 
cubit.cmd('group "g2" add surface 26 30 51') 
cubit.cmd('group "g3" add surface 47') 
cubit.cmd('group "g4" add surface 33 37 50') 
cubit.cmd('group "g5" add surface 25 29 49') 
cubit.cmd('group "g6" add surface 48') 

# --------
# x plane
# --------
cubit.cmd('surface 52 scheme trimesh') 
str1='surface 52 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 52') 
cubit.cmd('surface 50 scheme copy source surface 52 source vertex 4661 target vertex 4664 source curve 89 target curve 91 nosmoothing')
cubit.cmd('mesh surface 50')

cubit.cmd('surface 34 scheme trimesh') 
str1='surface 34 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 34') 
cubit.cmd('surface 33 scheme copy source surface 34 source vertex 4640 target vertex 4637 source curve 55 target curve 53 nosmoothing')
cubit.cmd('mesh surface 33') 

cubit.cmd('surface 38 scheme trimesh') 
str1='surface 38 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 38') 
cubit.cmd('surface 37 scheme copy source surface 38 source vertex 4644 target vertex 4641 source curve 61 target curve 59 nosmoothing')
cubit.cmd('mesh surface 37')

# --------
# y plane
# --------
#
cubit.cmd('surface 51 scheme trimesh') 
str1='surface 51 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 51') 
cubit.cmd('surface 49 scheme copy source surface 51 source vertex 4662 target vertex 4661 source curve 90 target curve 92 nosmoothing')
cubit.cmd('mesh surface 49')

cubit.cmd('surface 26 scheme trimesh') 
str1='surface 26 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 26') 
cubit.cmd('surface 25 scheme copy source surface 26 source vertex 4631 target vertex 4630 source curve 43 target curve 41 nosmoothing')
cubit.cmd('mesh surface 25') 

cubit.cmd('surface 30 scheme trimesh') 
str1='surface 30 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 30') 
cubit.cmd('surface 29 scheme copy source surface 30 source vertex 4635 target vertex 4634 source curve 49 target curve 47 nosmoothing')
cubit.cmd('mesh surface 29')

# --------
# z plane
# --------
cubit.cmd('surface 47 scheme trimesh') 
str1='surface 47 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 47') 
cubit.cmd('surface 48 scheme copy source surface 47 source vertex 4664 target vertex 4667 source curve 92 target curve 94 nosmoothing')
cubit.cmd('mesh surface 48')

#============================================================= 
# Mesh volume 
#============================================================= 
 
cubit.cmd('volume all scheme Tetmesh') 
cubit.cmd('mesh volume all') 

#================================================================================ 
# Defining blocks for elastic, transversely-isotropic and potential flow problems  
#================================================================================ 
 
vol=['10', '6,7,8,9', '6', '7', '8', '9']  
mat=['MAT_ELASTIC_1','MAT_ELASTIC_TRANSISO_1','PotentialFlow_1','PotentialFlow_2','PotentialFlow_3','PotentialFlow_4']  
for i in range(0, 6):  
    cubit.cmd('set duplicate block elements on') 
    str1='block  ' + str(i+1) +' volume '+vol[i]; cubit.cmd(str1)  
    str1='block  ' + str(i+1) +' name "'+mat[i] + '"'; cubit.cmd(str1)  
	
#============================================================= 
# Material properties for matrix part  
#============================================================= 
  
cubit.cmd('block 1 attribute count 2')  
Em=3.4e3; Enu=0.35;  #gig to mega as we used dimension in mm  

Elastic=[str(Em), str(Enu)]  
for i in range(0, 2):  
    str1='block 1 attribute index ' + str(i+1) +' '+Elastic[i]; cubit.cmd(str1)  	

#============================================================= 
# Material properties for fibres  
#============================================================= 

#to use as isotropic 
#cubit.cmd('block 2 attribute count 5')    
#Ep=Em; Ez=Em; nup=Enu; nupz=Enu;  Gzp=Em/(2*(1+Enu));  

cubit.cmd('block 2 attribute count 5')    
Ep=20.865e3; Ez=58.397e3; nup=0.386; nupz=0.08611; Gzp=8.465e3;    
   
TransIso=[str(Ep), str(Ez), str(nup), str(nupz), str(Gzp)]   
for i in range(0, 5):   
    str1='block 2 attribute index ' + str(i+1) +' '+TransIso[i]; cubit.cmd(str1) 

#============================================================= 
# Material properties for interface between fibres and matrix  
#============================================================= 
 
alpha_interf=500 
cubit.cmd('set duplicate block elements on')  
str1='block 7 surface 23 24 27 28 31 32 35 36'; cubit.cmd(str1)  
str1='block 7 name "MAT_INTERF_1"'; cubit.cmd(str1)  
cubit.cmd('block 7 attribute count 4')  
str1='block 7 attribute index 1 '+str(alpha_interf); cubit.cmd(str1)    #now we use 4 parameters for interface  
str1='block 7 attribute index 2 '+str(0.0); cubit.cmd(str1)  
str1='block 7 attribute index 3 '+str(0.0); cubit.cmd(str1)  
str1='block 7 attribute index 4 '+str(0.0); cubit.cmd(str1)   

#============================================================= 
# Defining interfaces 
#============================================================= 
 
Interface=['23', '24','27','28', '31', '32','35','36']   
for i in range(0, 8):   
    str1='sideset ' + str(i+1) +' surface '+Interface[i]; cubit.cmd(str1)   
    str1='sideset ' + str(i+1) +' name "interface'+str(i+1); cubit.cmd(str1) 

#============================================================= 
# Defining pressures for potential flow problem  
#============================================================= 
 
Pres=['25','26','29','30','33','34','37','38']; count=0;  count1=len(Interface);
for i in range(0, 4):  
    str1='create pressure '+str(count+1)+' on surface '+str(Pres[count])+' magnitude 1';  cubit.cmd(str1)  
    str1='create pressure '+str(count+2)+' on surface '+str(Pres[count+1])+' magnitude -1';  cubit.cmd(str1) 
    str1='sideset '+str(count1+1)+' name "PressureIO_' + str(i+1) + '_1"'; cubit.cmd(str1) 
    str1='sideset '+str(count1+2)+' name "PressureIO_' + str(i+1) + '_2"'; cubit.cmd(str1) 
    count=count+2;   count1=count1+2; 	

#============================================================= 
# Definign zero proessrues for potential flow problem (This should be of the same order as PotentialFlow blocks )
#============================================================= 
 
#zeroPressureNode=[545, 517, 30, 2]
#zeroPressureNode=[660, 618, 157, 115]
#zeroPressureNode=[561, 519, 44, 2]
# da3=0.003; H_RVE=2.28*a3
zeroPressureNode=[407, 389, 20, 2] 
# da3=0.002; H_RVE=2.22*a3
#zeroPressureNode=[409, 391, 20, 2] 
#zeroPressureNode=[331, 319, 14, 2] 
for i in range(0, 4):  
    str1='nodeset ' + str(i+1) + ' node ' + str(zeroPressureNode[i]); cubit.cmd(str1) 
    str1='nodeset ' + str(i+1)+' name "ZeroPressure_' + str(i+1)+ '"'; cubit.cmd(str1) 
	
#============================================================= 
# Defining surfaces for dispacement, traction and periodic boundary conditions  
#============================================================= 
  
cubit.cmd('sideset 101 surface 33 37 50 25 29 49 48')  # all -ve boundary surfaces for periodic boundary conditions  
cubit.cmd('sideset 102 surface 34 38 52 26 30 51 47')  # all +ve boundary surfaces  for periodic boundary conditions  
cubit.cmd('sideset 103 surface 34 38 52 26 30 51 47 33 37 50 25 29 49 48')  # all boundary surfaces  	

#============================================================= 
#Saving input RVE file  
#============================================================= 
 
cubit.cmd('save as "/Users/nxz6/Dropbox/DURACOMP_Cal/009_MOFEM/Meshes/RVE_TISO/RVE_Scida.cub" overwrite')

