#!python
#This scrip will create RVE including fibres and matrix, which can be used for all 
#three type of boundary conditions including dispalcement, traction and periodic. 

cubit.cmd('new')
#=============================================================
#Geometry Input parametrs
#=============================================================
a1=0.920
a2=0.920
a3=0.250
ag1=0.17
ag2=0.17

W_warp=a2-ag2/2
W_weft=a1-ag1/2

L_RVE=4*a2
W_RVE=4*a1
H_RVE=2.12*a3 

dy_w=W_warp/100
dy_g=ag2/50   
dx_w=W_weft/100
dx_g=ag1/50  

autofactor=5; 
 
#=============================================================
#Create vartices for splines to create splines
#=============================================================

import math
da3=0.014;
a3=a3+da3;
#---------------------
# Fill 1 path (14) top
#---------------------
coordx=-a1
coordy=-3*a2-dy_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordy=coordy+dy_w;
    else:
        coordy=coordy+dy_g;
    coordz=a3/2*(math.sin(-math.pi*(coordy)/(2*a2)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	


#---------------------
# Fill 2 path (12) top
#---------------------		
coordx=a1
coordy=-3*a2-dy_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordy=coordy+dy_w;
    else:
        coordy=coordy+dy_g;
    coordz=a3/2*(math.sin(math.pi*(coordy)/(2*a2)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	
		
#---------------------
# Warp 1 path (2) top
#---------------------
coordy=-a2
coordx=-3*a1-dx_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordx=coordx+dx_w;
    else:
        coordx=coordx+dx_g;
    coordz=a3/2*(math.sin(math.pi*(coordx)/(2*a1)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

#---------------------
# Warp 2 path (8) top
#---------------------
coordy=a2
coordx=-3*a1-dx_w 
for i in range(0, 751):
    if (i<101) or (i>150 and i<351) or (i>400 and i<601) or (i>650):
        coordx=coordx+dx_w;
    else:
        coordx=coordx+dx_g;
    coordz=a3/2*(math.sin(-math.pi*(coordx)/(2*a1)))+a3/2
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)			

#=============================================================
#Joint vertices to create splines 
#=============================================================

Tvertices=751;  
vertices=range(1,Tvertices+1); count1=0;   
for i in range(0, 4): 
    str1='create curve spline vertex '
    for j in range(125, 626):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+751;   

#=============================================================
#Creating yarns/inclusions with sinusoidal cross sections  
#=============================================================

a3=a3-da3;
#-------------------------------------
# Fill 1 front surface top profile (1)
#-------------------------------------
coordy=3*a2
coordx=-2*a1+ag1/2-dx_w
A_coef=-a3/2*math.sin(math.pi*ag1/4/a1)-a3/2
B_coef=math.pi/(ag1-2*a1)
C_coef=-math.pi*(ag1-4*a1)/2/(ag1-2*a1)
D_coef=-a3/2*math.sin(math.pi*ag1/4/a1)+a3/2 
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)

dzmax=A_coef*math.sin(B_coef*(-a1)+C_coef)+D_coef
dzmin=A_coef*math.sin(B_coef*(-ag1/2)+C_coef)+D_coef
dz_f1=dzmax-dzmin

#----------------------------------------
# Fill 1 front surface bottom profile (2)
#----------------------------------------	
A_coef=a3/2
B_coef=math.pi/(2*a1)
C_coef=0
D_coef=a3/2
coordy=3*a2
coordx=-2*a1+ag1/2-dx_w	
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)    	

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3004;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;

#-------------------------------------
# Fill 2 front surface top profile (5)
#-------------------------------------
coordy=3*a2
coordx=ag1/2-dx_w
A_coef=a3/2
B_coef=math.pi/(2*a1)
C_coef=0
D_coef=-a3/2
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef;
    coordz=coordz;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

dzmax=A_coef*math.sin(B_coef*a1+C_coef)+D_coef
dzmin=A_coef*math.sin(B_coef*ag1/2+C_coef)+D_coef
dz_f2=dzmax-dzmin

#----------------------------------------
# Fill 2 front surface bottom profile (6)
#----------------------------------------
coordy=3*a2
coordx=ag1/2-dx_w
A_coef=-a3/2*math.sin(math.pi*ag1/4/a1)-a3/2
B_coef=math.pi/(ag1-2*a1)
C_coef=math.pi*(ag1-4*a1)/2/(ag1-2*a1)
D_coef=a3/2*math.sin(math.pi*ag1/4/a1)-a3/2 
for i in range(0, 201):
    coordx=coordx+dx_w;
    coordz=A_coef*math.sin(B_coef*coordx+C_coef)+D_coef;
    coordz=coordz;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)	

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3406;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;	

#-------------------------------------
# Wrap 1 front surface top profile (9)
#-------------------------------------

coordx=3*a1
coordy=-2*a2+ag2/2-dy_w

A_coef=a3/2
B_coef=-math.pi/(2*a2)
C_coef=0
D_coef=-a3/2
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef 
    coordz=coordz;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)
    
dzmax=A_coef*math.sin(B_coef*(-a2)+C_coef)+D_coef
dzmin=A_coef*math.sin(B_coef*(-ag2/2)+C_coef)+D_coef
dz_w1=dzmax-dzmin
    
#-----------------------------------------
# Warp 1 front surface bottom profile (10)
#-----------------------------------------	
coordx=3*a1
coordy=-2*a2+ag2/2-dy_w	
A_coef=-a3/2*math.sin(math.pi*ag2/4/a2)-a3/2
B_coef=-math.pi/(ag2-2*a2)
C_coef=math.pi*(ag2-4*a2)/2/(ag2-2*a2)
D_coef=a3/2*math.sin(math.pi*ag2/4/a2)-a3/2 
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef; 
    coordz=coordz;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)  

Tvertices=201;  
vertices=range(1,Tvertices+1); count1=3808;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;
    

#-------------------------------------
# Wrap 2 front surface top profile (13)
#-------------------------------------
coordx=3*a1
coordy=ag2/2-dy_w
A_coef=-a3/2*math.sin(math.pi*ag2/4/a2)-a3/2
B_coef=-math.pi/(ag2-2*a2)
C_coef=-math.pi*(ag2-4*a2)/2/(ag2-2*a2)
D_coef=-a3/2*math.sin(math.pi*ag2/4/a2)+a3/2 
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef
    coordz=coordz+da3;
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)

dzmax=A_coef*math.sin(B_coef*a2+C_coef)+D_coef
dzmin=A_coef*math.sin(B_coef*ag2/2+C_coef)+D_coef
dz_w2=dzmax-dzmin
#-----------------------------------------
# Warp 2 front surface bottom profile (14)
#-----------------------------------------	
coordx=3*a1
coordy=ag2/2-dy_w	
A_coef=a3/2
B_coef=-math.pi/(2*a2)
C_coef=0
D_coef=a3/2
for i in range(0, 201):
    coordy=coordy+dy_w;
    coordz=A_coef*math.sin(B_coef*coordy+C_coef)+D_coef
    coordz=coordz+da3;	
    str1='create vertex ' + str(coordx) +' '+str(coordy)+' '+str(coordz)+' color' ;
    cubit.cmd(str1)  	
 
Tvertices=201;  
vertices=range(1,Tvertices+1); count1=4210;   
for i in range(0, 2): 
    str1='create curve spline vertex '
    for j in range(0, 201):
        str1=str1+' '+ str(count1+vertices[j])
    cubit.cmd(str1);  count1=count1+201;
 

# Create yarn cross-section and 
#        sweep along guideline/path to generate yarn volume
# 

# Fill/weft 1-2
cubit.cmd('create surface curve 5 6')  
cubit.cmd('create surface curve 7 8') 
# Warp 1-2
cubit.cmd('create surface curve 9 10')  
cubit.cmd('create surface curve 11 12')  

str1='move surface 1 x 0 y '+str(-a1)+' z '+str(-(a3+da3)/2); cubit.cmd(str1);
str1='move surface 2 x 0 y '+str(-a1)+' z '+str((a3+da3)/2); cubit.cmd(str1);
str1='move surface 3 x '+str(-a2)+' y 0 z '+str((a3+da3)/2); cubit.cmd(str1);
str1='move surface 4 x '+str(-a2)+' y 0 z '+str(-(a3+da3)/2); cubit.cmd(str1);

str1='curve 1 copy move x '+str(-W_weft)+' y 0 z '+str(-dz_f1);cubit.cmd(str1)
str1='curve 1 copy move x '+str(W_weft)+' y 0 z '+str(-dz_f1);cubit.cmd(str1)
str1='curve 2 copy move x '+str(-W_weft)+' y 0 z '+str(-dz_f2);cubit.cmd(str1)
str1='curve 2 copy move x '+str(W_weft)+' y 0 z '+str(-dz_f2);cubit.cmd(str1)

str1='curve 3 copy move x 0 y '+str(-W_warp)+' z '+str(-dz_w1);cubit.cmd(str1)
str1='curve 3 copy move x 0 y '+str(W_warp)+' z '+str(-dz_w1);cubit.cmd(str1)
str1='curve 4 copy move x 0 y '+str(-W_warp)+' z '+str(-dz_w2);cubit.cmd(str1)
str1='curve 4 copy move x 0 y '+str(W_warp)+' z '+str(-dz_w2);cubit.cmd(str1)

str1='surface 1 copy move x 0 y '+str(-W_RVE)+' z 0';cubit.cmd(str1)
str1='surface 2 copy move x 0 y '+str(-W_RVE)+' z 0';cubit.cmd(str1)
str1='surface 3 copy move x '+str(-L_RVE)+' y 0 z 0';cubit.cmd(str1)
str1='surface 4 copy move x '+str(-L_RVE)+' y 0 z 0';cubit.cmd(str1)

cubit.cmd('create surface 5 22 13 14')
cubit.cmd('create surface 6 21 13 14')
cubit.cmd('create surface 7 24 15 16')
cubit.cmd('create surface 8 23 15 16')
cubit.cmd('create surface 9 26 17 18')
cubit.cmd('create surface 10 25 17 18')
cubit.cmd('create surface 11 28 19 20')
cubit.cmd('create surface 12 27 19 20')

cubit.cmd('create volume surface 1 5 9 10')
cubit.cmd('create volume surface 2 6 11 12')
cubit.cmd('create volume surface 3 7 13 14')
cubit.cmd('create volume surface 4 8 15 16')

#=============================================================
#Deletion of remaining free vertices, curves and bodies 
#=============================================================

cubit.cmd('delete vertex all')
cubit.cmd('delete curve all')

#=============================================================
#Create matrix and imprint and merge fibres and matrix to create common surfaces
#=============================================================

str1='brick x '+str(L_RVE)+' y '+str(W_RVE)+' z '+str(H_RVE); cubit.cmd(str1) 

cubit.cmd('intersect volume all keep')
cubit.cmd('subtract volume 18 19 20 21 from volume 17 keep')
cubit.cmd('delete volume 10 12 14 16 17')
cubit.cmd('imprint volume 18 19 20 21 22')   
cubit.cmd('merge volume 18 19 20 21 22') 

#=============================================================
#Meshing negative x, y and z face of the RVE and coping the same to its positive faces
#=============================================================
# 1: +x 2: +y 3: +z
# 4: -x 5: -y 6: -z  
cubit.cmd('group "g1" add surface 34 38 52') 
cubit.cmd('group "g2" add surface 26 30 51') 
cubit.cmd('group "g3" add surface 47') 
cubit.cmd('group "g4" add surface 33 37 50') 
cubit.cmd('group "g5" add surface 25 29 49') 
cubit.cmd('group "g6" add surface 48') 

# --------
# x plane
# --------
cubit.cmd('surface 52 scheme trimesh') 
str1='surface 52 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 52') 
cubit.cmd('surface 50 scheme copy source surface 52 source vertex 4697 target vertex 4700 source curve 113 target curve 115 nosmoothing')
cubit.cmd('mesh surface 50')

cubit.cmd('surface 34 scheme trimesh') 
str1='surface 34 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 34') 
cubit.cmd('surface 33 scheme copy source surface 34 source vertex 4674 target vertex 4673 source curve 78 target curve 80 nosmoothing')
cubit.cmd('mesh surface 33') 

cubit.cmd('surface 38 scheme trimesh') 
str1='surface 38 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 38') 
cubit.cmd('surface 37 scheme copy source surface 38 source vertex 4678 target vertex 4677 source curve 84 target curve 86 nosmoothing')
cubit.cmd('mesh surface 37')

# --------
# y plane
# --------
#
cubit.cmd('surface 51 scheme trimesh') 
str1='surface 51 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 51') 
cubit.cmd('surface 49 scheme copy source surface 51 source vertex 4698 target vertex 4697 source curve 114 target curve 116 nosmoothing')
cubit.cmd('mesh surface 49')

cubit.cmd('surface 26 scheme trimesh') 
str1='surface 26 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 26') 
cubit.cmd('surface 25 scheme copy source surface 26 source vertex 4666 target vertex 4665 source curve 68 target curve 66 nosmoothing')
cubit.cmd('mesh surface 25') 

cubit.cmd('surface 30 scheme trimesh') 
str1='surface 30 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 30') 
cubit.cmd('surface 29 scheme copy source surface 30 source vertex 4670 target vertex 4669 source curve 74 target curve 72 nosmoothing')
cubit.cmd('mesh surface 29')

# --------
# z plane
# --------
cubit.cmd('surface 47 scheme trimesh') 
str1='surface 47 size auto factor '+str(autofactor); cubit.cmd(str1)
cubit.cmd('mesh surface 47') 
cubit.cmd('surface 48 scheme copy source surface 47 source vertex 4700 target vertex 4703 source curve 116 target curve 118 nosmoothing')
cubit.cmd('mesh surface 48')

#============================================================= 
# Mesh volume 
#============================================================= 
 
cubit.cmd('volume all scheme Tetmesh') 
cubit.cmd('mesh volume all') 
 
#================================================================================ 
# Defining blocks for elastic, transversely-isotropic and potential flow problems  
#================================================================================ 
 
vol=['22', '18,19,20,21', '18', '19', '20', '21']  
mat=['MAT_ELASTIC_1','MAT_ELASTIC_TRANSISO_1','PotentialFlow_1','PotentialFlow_2','PotentialFlow_3','PotentialFlow_4']  
for i in range(0, 6):  
    cubit.cmd('set duplicate block elements on') 
    str1='block  ' + str(i+1) +' volume '+vol[i]; cubit.cmd(str1)  
    str1='block  ' + str(i+1) +' name "'+mat[i] + '"'; cubit.cmd(str1)  
	
#============================================================= 
# Material properties for matrix part  
#============================================================= 
  
cubit.cmd('block 1 attribute count 2')  
Em=3.4e3; Enu=0.35;  #gig to mega as we used dimension in mm  

Elastic=[str(Em), str(Enu)]  
for i in range(0, 2):  
    str1='block 1 attribute index ' + str(i+1) +' '+Elastic[i]; cubit.cmd(str1)  	

#============================================================= 
# Material properties for fibres  
#============================================================= 

#to use as isotropic 
#cubit.cmd('block 2 attribute count 5')    
#Ep=Em; Ez=Em; nup=Enu; nupz=Enu;  Gzp=Em/(2*(1+Enu));  

cubit.cmd('block 2 attribute count 5')    
Ep=19.489e3; Ez=160.755e3; nup=0.415; nupz=0.03395; Gzp=7.393e3;    
   
TransIso=[str(Ep), str(Ez), str(nup), str(nupz), str(Gzp)]   
for i in range(0, 5):   
    str1='block 2 attribute index ' + str(i+1) +' '+TransIso[i]; cubit.cmd(str1) 

#============================================================= 
# Material properties for interface between fibres and matrix  
#============================================================= 
 
alpha_interf=500 
cubit.cmd('set duplicate block elements on')  
str1='block 7 surface 23 24 27 28 31 32 35 36'; cubit.cmd(str1)  
str1='block 7 name "MAT_INTERF_1"'; cubit.cmd(str1)  
cubit.cmd('block 7 attribute count 4')  
str1='block 7 attribute index 1 '+str(alpha_interf); cubit.cmd(str1)    #now we use 4 parameters for interface  
str1='block 7 attribute index 2 '+str(0.0); cubit.cmd(str1)  
str1='block 7 attribute index 3 '+str(0.0); cubit.cmd(str1)  
str1='block 7 attribute index 4 '+str(0.0); cubit.cmd(str1)   

#============================================================= 
# Defining interfaces 
#============================================================= 
 
Interface=['23', '24','27','28', '31', '32','35','36']   
for i in range(0, 8):   
    str1='sideset ' + str(i+1) +' surface '+Interface[i]; cubit.cmd(str1)   
    str1='sideset ' + str(i+1) +' name "interface'+str(i+1); cubit.cmd(str1) 

#============================================================= 
# Defining pressures for potential flow problem  
#============================================================= 
 
Pres=['25','26','29','30','33','34','37','38']; count=0;  count1=len(Interface);
for i in range(0, 4):  
    str1='create pressure '+str(count+1)+' on surface '+str(Pres[count])+' magnitude 1';  cubit.cmd(str1)  
    str1='create pressure '+str(count+2)+' on surface '+str(Pres[count+1])+' magnitude -1';  cubit.cmd(str1) 
    str1='sideset '+str(count1+1)+' name "PressureIO_' + str(i+1) + '_1"'; cubit.cmd(str1) 
    str1='sideset '+str(count1+2)+' name "PressureIO_' + str(i+1) + '_2"'; cubit.cmd(str1) 
    count=count+2;   count1=count1+2; 	

#============================================================= 
# Definign zero proessrues for potential flow problem (This should be of the same order as PotentialFlow blocks )
#============================================================= 

#zeroPressureNode=[178, 172, 8, 2] # autofactor = 8
#zeroPressureNode=[233, 223, 12, 2] # autofactor = 7
#zeroPressureNode=[290, 276, 16, 2] # autofactor = 6
zeroPressureNode=[366, 344, 24, 2] # autofactor = 5
# zeroPressureNode=[816, 782, 36, 2] # autofactor = 4
for i in range(0, 4):  
    str1='nodeset ' + str(i+1) + ' node ' + str(zeroPressureNode[i]); cubit.cmd(str1) 
    str1='nodeset ' + str(i+1)+' name "ZeroPressure_' + str(i+1)+ '"'; cubit.cmd(str1) 
	
#============================================================= 
# Defining surfaces for dispacement, traction and periodic boundary conditions  
#============================================================= 
  
cubit.cmd('sideset 101 surface 33 37 50 25 29 49 48')  # all -ve boundary surfaces for periodic boundary conditions  
cubit.cmd('sideset 102 surface 34 38 52 26 30 51 47')  # all +ve boundary surfaces  for periodic boundary conditions  
cubit.cmd('sideset 103 surface 34 38 52 26 30 51 47 33 37 50 25 29 49 48')  # all boundary surfaces  	

#============================================================= 
#Saving input RVE file  
#============================================================= 
  
cubit.cmd('save as "/Users/nxz6/Dropbox/DURACOMP_Cal/009_MOFEM/Meshes/RVE_TISO/RVE_CERL_2_M5.cub" overwrite')